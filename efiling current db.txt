-- public.access_control definition

-- Drop table

-- DROP TABLE public.access_control;

CREATE TABLE public.access_control (
	id serial4 NOT NULL,
	resource_type varchar(50) NOT NULL,
	resource_id int4 NOT NULL,
	user_id int4 NULL,
	role_id int4 NULL,
	ip_address inet NULL,
	"action" varchar(50) NOT NULL,
	allowed bool NOT NULL,
	reason text NULL,
	"timestamp" timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	session_id varchar(255) NULL,
	user_agent text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT access_control_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_access_control_resource ON public.access_control USING btree (resource_type, resource_id);
CREATE INDEX idx_access_control_role ON public.access_control USING btree (role_id);
CREATE INDEX idx_access_control_timestamp ON public.access_control USING btree ("timestamp");
CREATE INDEX idx_access_control_user ON public.access_control USING btree (user_id);


-- public.district definition

-- Drop table

-- DROP TABLE public.district;

CREATE TABLE public.district (
	id serial4 NOT NULL,
	title varchar(255) NOT NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT district_pkey PRIMARY KEY (id)
);


-- public.efiling_daak_categories definition

-- Drop table

-- DROP TABLE public.efiling_daak_categories;

CREATE TABLE public.efiling_daak_categories (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	code varchar(50) NOT NULL,
	description text NULL,
	icon varchar(100) NULL,
	color varchar(20) NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_daak_categories_code_key UNIQUE (code),
	CONSTRAINT efiling_daak_categories_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_daak_categories_active ON public.efiling_daak_categories USING btree (is_active) WHERE (is_active = true);
CREATE INDEX idx_daak_categories_code ON public.efiling_daak_categories USING btree (code);

-- Table Triggers

create trigger trigger_efiling_daak_categories_updated_at before
update
    on
    public.efiling_daak_categories for each row execute function update_updated_at_column();


-- public.efiling_file_attachments definition

-- Drop table

-- DROP TABLE public.efiling_file_attachments;

CREATE TABLE public.efiling_file_attachments (
	id varchar(255) NOT NULL,
	file_id varchar(255) NOT NULL,
	file_name varchar(255) NOT NULL,
	file_size int8 NOT NULL,
	file_type varchar(100) NOT NULL,
	file_url text NULL,
	uploaded_by varchar(255) NOT NULL,
	uploaded_at timestamp DEFAULT now() NULL,
	deleted_at timestamp NULL,
	is_active bool DEFAULT true NULL,
	CONSTRAINT efiling_file_attachments_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_efiling_file_attachments_file ON public.efiling_file_attachments USING btree (file_id);


-- public.efiling_file_status definition

-- Drop table

-- DROP TABLE public.efiling_file_status;

CREATE TABLE public.efiling_file_status (
	id serial4 NOT NULL,
	"name" varchar(100) NOT NULL,
	code varchar(50) NOT NULL,
	description text NULL,
	color varchar(20) DEFAULT '#000000'::character varying NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_file_status_code_key UNIQUE (code),
	CONSTRAINT efiling_file_status_pkey PRIMARY KEY (id)
);


-- public.efiling_otp_codes definition

-- Drop table

-- DROP TABLE public.efiling_otp_codes;

CREATE TABLE public.efiling_otp_codes (
	id serial4 NOT NULL,
	user_id varchar(255) NOT NULL,
	otp_code varchar(10) NOT NULL,
	"method" varchar(50) NOT NULL,
	expires_at timestamp NOT NULL,
	created_at timestamp DEFAULT now() NULL,
	CONSTRAINT efiling_otp_codes_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_otp_codes_user_id_method_key UNIQUE (user_id, method)
);
CREATE INDEX idx_efiling_otp_codes_expires ON public.efiling_otp_codes USING btree (expires_at);
CREATE INDEX idx_efiling_otp_codes_user_method ON public.efiling_otp_codes USING btree (user_id, method);


-- public.efiling_permissions definition

-- Drop table

-- DROP TABLE public.efiling_permissions;

CREATE TABLE public.efiling_permissions (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	description text NULL,
	resource_type varchar(100) NOT NULL,
	"action" varchar(100) NOT NULL,
	resource_subtype varchar(100) NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_permissions_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_permissions_unique UNIQUE (resource_type, action, resource_subtype)
);
CREATE INDEX idx_efiling_permissions_resource_action ON public.efiling_permissions USING btree (resource_type, action);


-- public.efiling_role_groups definition

-- Drop table

-- DROP TABLE public.efiling_role_groups;

CREATE TABLE public.efiling_role_groups (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	code varchar(50) NOT NULL,
	description text NULL,
	role_codes jsonb DEFAULT '[]'::jsonb NOT NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_role_groups_code_key UNIQUE (code),
	CONSTRAINT efiling_role_groups_pkey PRIMARY KEY (id)
);


-- public.efiling_tools definition

-- Drop table

-- DROP TABLE public.efiling_tools;

CREATE TABLE public.efiling_tools (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	tool_type varchar(50) NOT NULL,
	description text NULL,
	icon varchar(100) NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_tools_pkey PRIMARY KEY (id)
);


-- public.efiling_user_actions definition

-- Drop table

-- DROP TABLE public.efiling_user_actions;

CREATE TABLE public.efiling_user_actions (
	id serial4 NOT NULL,
	file_id varchar(255) NULL,
	user_id varchar(255) NOT NULL,
	action_type varchar(100) NOT NULL,
	description text NULL,
	"timestamp" timestamp NOT NULL,
	created_at timestamp DEFAULT now() NULL,
	user_type varchar(50) NOT NULL,
	user_role int4 NOT NULL,
	user_name varchar(255) NOT NULL,
	user_email varchar(255) NOT NULL,
	entity_type varchar(100) NOT NULL,
	entity_name varchar(255) NULL,
	details jsonb NULL,
	ip_address inet NULL,
	user_agent text NULL,
	updated_at timestamptz DEFAULT now() NULL,
	CONSTRAINT efiling_user_actions_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_efiling_user_actions_entity_type ON public.efiling_user_actions USING btree (entity_type);
CREATE INDEX idx_efiling_user_actions_file ON public.efiling_user_actions USING btree (file_id);
CREATE INDEX idx_efiling_user_actions_timestamp ON public.efiling_user_actions USING btree ("timestamp");
CREATE INDEX idx_efiling_user_actions_updated_at ON public.efiling_user_actions USING btree (updated_at);
CREATE INDEX idx_efiling_user_actions_user ON public.efiling_user_actions USING btree (user_id);
CREATE INDEX idx_efiling_user_actions_user_role ON public.efiling_user_actions USING btree (user_role);
CREATE INDEX idx_efiling_user_actions_user_type ON public.efiling_user_actions USING btree (user_type);
CREATE INDEX idx_efiling_user_actions_user_type_role ON public.efiling_user_actions USING btree (user_type, user_role);

-- Table Triggers

create trigger trigger_update_efiling_user_actions_updated_at before
update
    on
    public.efiling_user_actions for each row execute function update_efiling_user_actions_updated_at();


-- public.efiling_user_signatures definition

-- Drop table

-- DROP TABLE public.efiling_user_signatures;

CREATE TABLE public.efiling_user_signatures (
	id varchar(255) NOT NULL,
	user_id varchar(255) NOT NULL,
	signature_name varchar(255) NOT NULL,
	signature_type varchar(50) NOT NULL,
	file_name varchar(255) NULL,
	file_size int8 NULL,
	file_type varchar(100) NULL,
	file_url text NULL,
	signature_data text NULL,
	created_at timestamp DEFAULT now() NULL,
	is_active bool DEFAULT true NULL,
	signature_color varchar(20) DEFAULT 'black'::character varying NULL,
	signature_text text NULL,
	signature_font varchar(100) DEFAULT 'Arial'::character varying NULL,
	CONSTRAINT efiling_user_signatures_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_user_signatures_signature_color_check CHECK (((signature_color)::text = ANY ((ARRAY['black'::character varying, 'blue'::character varying, 'red'::character varying])::text[])))
);
CREATE INDEX idx_efiling_user_signatures_color ON public.efiling_user_signatures USING btree (signature_color);
CREATE INDEX idx_efiling_user_signatures_user ON public.efiling_user_signatures USING btree (user_id);


-- public.efiling_zones definition

-- Drop table

-- DROP TABLE public.efiling_zones;

CREATE TABLE public.efiling_zones (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	ce_type varchar(100) NULL,
	description text NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_zones_name_key UNIQUE (name),
	CONSTRAINT efiling_zones_pkey PRIMARY KEY (id)
);


-- public.public_access_log definition

-- Drop table

-- DROP TABLE public.public_access_log;

CREATE TABLE public.public_access_log (
	id serial4 NOT NULL,
	media_type varchar(50) NOT NULL,
	media_id int4 NOT NULL,
	ip_address inet NOT NULL,
	user_agent text NULL,
	referer text NULL,
	access_granted bool NOT NULL,
	reason text NULL,
	response_time_ms int4 NULL,
	"timestamp" timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	session_id varchar(255) NULL,
	geographic_location jsonb NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT public_access_log_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_public_access_granted ON public.public_access_log USING btree (access_granted);
CREATE INDEX idx_public_access_ip ON public.public_access_log USING btree (ip_address);
CREATE INDEX idx_public_access_media ON public.public_access_log USING btree (media_type, media_id);
CREATE INDEX idx_public_access_timestamp ON public.public_access_log USING btree ("timestamp");


-- public.rate_limiting definition

-- Drop table

-- DROP TABLE public.rate_limiting;

CREATE TABLE public.rate_limiting (
	id serial4 NOT NULL,
	identifier varchar(255) NOT NULL,
	rate_limit_type varchar(50) NOT NULL,
	request_count int4 DEFAULT 1 NULL,
	first_request timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	last_request timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	window_start timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	is_blocked bool DEFAULT false NULL,
	block_reason text NULL,
	block_until timestamp NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT rate_limiting_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_rate_limiting_blocked ON public.rate_limiting USING btree (is_blocked);
CREATE INDEX idx_rate_limiting_identifier ON public.rate_limiting USING btree (identifier);
CREATE INDEX idx_rate_limiting_type ON public.rate_limiting USING btree (rate_limit_type);
CREATE INDEX idx_rate_limiting_window ON public.rate_limiting USING btree (window_start);

-- Table Triggers

create trigger update_rate_limiting_updated_at before
update
    on
    public.rate_limiting for each row execute function update_updated_at_column();


-- public."role" definition

-- Drop table

-- DROP TABLE public."role";

CREATE TABLE public."role" (
	id serial4 NOT NULL,
	title varchar(255) NOT NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT role_pkey PRIMARY KEY (id)
);


-- public.secure_files definition

-- Drop table

-- DROP TABLE public.secure_files;

CREATE TABLE public.secure_files (
	id serial4 NOT NULL,
	original_name varchar(255) NOT NULL,
	secure_name varchar(255) NOT NULL,
	file_hash varchar(64) NOT NULL,
	checksum varchar(32) NOT NULL,
	file_size int8 NOT NULL,
	file_type varchar(50) NOT NULL,
	mime_type varchar(100) NOT NULL,
	uploaded_by int4 NOT NULL,
	uploaded_at timestamp NOT NULL,
	storage_path text NOT NULL,
	is_active bool DEFAULT true NULL,
	access_count int4 DEFAULT 0 NULL,
	last_accessed timestamp NULL,
	virus_scan_status varchar(20) DEFAULT 'PENDING'::character varying NULL,
	virus_scan_date timestamp NULL,
	virus_scan_result jsonb NULL,
	file_integrity_verified bool DEFAULT false NULL,
	integrity_check_date timestamp NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT secure_files_pkey PRIMARY KEY (id),
	CONSTRAINT secure_files_secure_name_key UNIQUE (secure_name),
	CONSTRAINT secure_files_virus_scan_status_check CHECK (((virus_scan_status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('CLEAN'::character varying)::text, ('INFECTED'::character varying)::text, ('ERROR'::character varying)::text])))
);
CREATE INDEX idx_secure_files_active ON public.secure_files USING btree (is_active);
CREATE INDEX idx_secure_files_hash ON public.secure_files USING btree (file_hash);
CREATE INDEX idx_secure_files_type ON public.secure_files USING btree (file_type);
CREATE INDEX idx_secure_files_uploaded_by ON public.secure_files USING btree (uploaded_by);
CREATE INDEX idx_secure_files_virus_scan ON public.secure_files USING btree (virus_scan_status);

-- Table Triggers

create trigger update_secure_files_updated_at before
update
    on
    public.secure_files for each row execute function update_updated_at_column();


-- public.security_audit_log definition

-- Drop table

-- DROP TABLE public.security_audit_log;

CREATE TABLE public.security_audit_log (
	id serial4 NOT NULL,
	table_name varchar(100) NOT NULL,
	record_id int4 NOT NULL,
	"action" varchar(20) NOT NULL,
	old_values jsonb NULL,
	new_values jsonb NULL,
	changed_by int4 NULL,
	changed_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	ip_address inet NULL,
	user_agent text NULL,
	session_id varchar(255) NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT security_audit_log_action_check CHECK (((action)::text = ANY (ARRAY[('INSERT'::character varying)::text, ('UPDATE'::character varying)::text, ('DELETE'::character varying)::text]))),
	CONSTRAINT security_audit_log_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_security_audit_action ON public.security_audit_log USING btree (action);
CREATE INDEX idx_security_audit_changed_by ON public.security_audit_log USING btree (changed_by);
CREATE INDEX idx_security_audit_table ON public.security_audit_log USING btree (table_name, record_id);
CREATE INDEX idx_security_audit_timestamp ON public.security_audit_log USING btree (changed_at);


-- public.security_config definition

-- Drop table

-- DROP TABLE public.security_config;

CREATE TABLE public.security_config (
	id serial4 NOT NULL,
	config_key varchar(100) NOT NULL,
	config_value jsonb NOT NULL,
	description text NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT security_config_config_key_key UNIQUE (config_key),
	CONSTRAINT security_config_pkey PRIMARY KEY (id)
);

-- Table Triggers

create trigger update_security_config_updated_at before
update
    on
    public.security_config for each row execute function update_updated_at_column();


-- public.security_events definition

-- Drop table

-- DROP TABLE public.security_events;

CREATE TABLE public.security_events (
	id serial4 NOT NULL,
	event_type varchar(100) NOT NULL,
	user_id int4 NULL,
	ip_address inet NOT NULL,
	details jsonb NULL,
	severity varchar(20) DEFAULT 'INFO'::character varying NULL,
	"timestamp" timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	user_agent text NULL,
	session_id varchar(255) NULL,
	request_method varchar(10) NULL,
	request_url text NULL,
	response_status int4 NULL,
	processing_time_ms int4 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT security_events_pkey PRIMARY KEY (id),
	CONSTRAINT security_events_severity_check CHECK (((severity)::text = ANY (ARRAY[('INFO'::character varying)::text, ('WARNING'::character varying)::text, ('ERROR'::character varying)::text, ('CRITICAL'::character varying)::text])))
);
CREATE INDEX idx_security_events_ip ON public.security_events USING btree (ip_address);
CREATE INDEX idx_security_events_severity ON public.security_events USING btree (severity);
CREATE INDEX idx_security_events_timestamp ON public.security_events USING btree ("timestamp");
CREATE INDEX idx_security_events_type ON public.security_events USING btree (event_type);
CREATE INDEX idx_security_events_user ON public.security_events USING btree (user_id);


-- public.socialmediaperson definition

-- Drop table

-- DROP TABLE public.socialmediaperson;

CREATE TABLE public.socialmediaperson (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	email varchar(255) NOT NULL,
	contact_number varchar(50) NULL,
	address text NULL,
	"role" int4 NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	"password" varchar(255) NOT NULL,
	image varchar(250) NULL,
	session_token varchar(255) NULL,
	CONSTRAINT socialmediaperson_email_key UNIQUE (email),
	CONSTRAINT socialmediaperson_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_socialmediaperson_email ON public.socialmediaperson USING btree (email);
CREATE INDEX idx_socialmediaperson_role ON public.socialmediaperson USING btree (role);


-- public.spatial_ref_sys definition

-- Drop table

-- DROP TABLE public.spatial_ref_sys;

CREATE TABLE public.spatial_ref_sys (
	srid int4 NOT NULL,
	auth_name varchar(256) NULL,
	auth_srid int4 NULL,
	srtext varchar(2048) NULL,
	proj4text varchar(2048) NULL,
	CONSTRAINT spatial_ref_sys_pkey PRIMARY KEY (srid),
	CONSTRAINT spatial_ref_sys_srid_check CHECK (((srid > 0) AND (srid <= 998999)))
);


-- public.status definition

-- Drop table

-- DROP TABLE public.status;

CREATE TABLE public.status (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT status_pkey PRIMARY KEY (id)
);


-- public.suspicious_activity definition

-- Drop table

-- DROP TABLE public.suspicious_activity;

CREATE TABLE public.suspicious_activity (
	id serial4 NOT NULL,
	ip_address inet NOT NULL,
	user_id int4 NULL,
	activity_type varchar(100) NOT NULL,
	patterns jsonb NOT NULL,
	severity varchar(20) DEFAULT 'WARNING'::character varying NULL,
	description text NULL,
	user_agent text NULL,
	referer text NULL,
	request_count int4 DEFAULT 1 NULL,
	first_detected timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	last_detected timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	is_blocked bool DEFAULT false NULL,
	block_reason text NULL,
	block_until timestamp NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT suspicious_activity_pkey PRIMARY KEY (id),
	CONSTRAINT suspicious_activity_severity_check CHECK (((severity)::text = ANY (ARRAY[('LOW'::character varying)::text, ('MEDIUM'::character varying)::text, ('HIGH'::character varying)::text, ('CRITICAL'::character varying)::text])))
);
CREATE INDEX idx_suspicious_activity_blocked ON public.suspicious_activity USING btree (is_blocked);
CREATE INDEX idx_suspicious_activity_ip ON public.suspicious_activity USING btree (ip_address);
CREATE INDEX idx_suspicious_activity_severity ON public.suspicious_activity USING btree (severity);
CREATE INDEX idx_suspicious_activity_type ON public.suspicious_activity USING btree (activity_type);

-- Table Triggers

create trigger update_suspicious_activity_updated_at before
update
    on
    public.suspicious_activity for each row execute function update_updated_at_column();


-- public.user_actions definition

-- Drop table

-- DROP TABLE public.user_actions;

CREATE TABLE public.user_actions (
	id serial4 NOT NULL,
	user_id int4 NOT NULL,
	user_type varchar(50) NOT NULL,
	user_role int4 NOT NULL,
	user_name varchar(255) NOT NULL,
	user_email varchar(255) NOT NULL,
	action_type varchar(100) NOT NULL,
	entity_type varchar(100) NOT NULL,
	entity_id int4 NULL,
	entity_name varchar(255) NULL,
	details jsonb NULL,
	ip_address inet NULL,
	user_agent text NULL,
	created_at timestamptz DEFAULT now() NULL,
	updated_at timestamptz DEFAULT now() NULL,
	CONSTRAINT user_actions_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_user_actions_action_type ON public.user_actions USING btree (action_type);
CREATE INDEX idx_user_actions_created_at ON public.user_actions USING btree (created_at);
CREATE INDEX idx_user_actions_entity_id ON public.user_actions USING btree (entity_id);
CREATE INDEX idx_user_actions_entity_type ON public.user_actions USING btree (entity_type);
CREATE INDEX idx_user_actions_user_id ON public.user_actions USING btree (user_id);
CREATE INDEX idx_user_actions_user_type ON public.user_actions USING btree (user_type);
CREATE INDEX idx_user_actions_user_type_role ON public.user_actions USING btree (user_type, user_role);

-- Table Triggers

create trigger update_user_actions_updated_at before
update
    on
    public.user_actions for each row execute function update_updated_at_column();


-- public.users definition

-- Drop table

-- DROP TABLE public.users;

CREATE TABLE public.users (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	email varchar(255) NOT NULL,
	"password" varchar(255) NOT NULL,
	contact_number varchar(50) NULL,
	image varchar(250) NULL,
	"role" int4 NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	session_token varchar(255) NULL,
	cnic varchar(15) NULL,
	CONSTRAINT users_email_key UNIQUE (email),
	CONSTRAINT users_pkey PRIMARY KEY (id)
);
CREATE UNIQUE INDEX idx_users_cnic ON public.users USING btree (cnic) WHERE (cnic IS NOT NULL);
CREATE INDEX idx_users_email ON public.users USING btree (email);
CREATE INDEX idx_users_role ON public.users USING btree (role);


-- public.ce_users definition

-- Drop table

-- DROP TABLE public.ce_users;

CREATE TABLE public.ce_users (
	id serial4 NOT NULL,
	user_id int4 NOT NULL,
	designation varchar(255) NULL,
	address text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT ce_users_pkey PRIMARY KEY (id),
	CONSTRAINT ce_users_user_id_key UNIQUE (user_id),
	CONSTRAINT ce_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE
);
CREATE INDEX idx_ce_users_user_id ON public.ce_users USING btree (user_id);


-- public.efiling_departments definition

-- Drop table

-- DROP TABLE public.efiling_departments;

CREATE TABLE public.efiling_departments (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	code varchar(50) NOT NULL,
	description text NULL,
	parent_department_id int4 NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	department_type varchar(50) DEFAULT 'district'::character varying NULL,
	CONSTRAINT efiling_departments_code_key UNIQUE (code),
	CONSTRAINT efiling_departments_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_departments_parent_department_id_fkey FOREIGN KEY (parent_department_id) REFERENCES public.efiling_departments(id)
);
CREATE INDEX idx_departments_type ON public.efiling_departments USING btree (department_type);


-- public.efiling_file_categories definition

-- Drop table

-- DROP TABLE public.efiling_file_categories;

CREATE TABLE public.efiling_file_categories (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	code varchar(50) NOT NULL,
	description text NULL,
	department_id int4 NULL,
	is_work_related bool DEFAULT false NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_file_categories_code_key UNIQUE (code),
	CONSTRAINT efiling_file_categories_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_file_categories_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id)
);


-- public.efiling_roles definition

-- Drop table

-- DROP TABLE public.efiling_roles;

CREATE TABLE public.efiling_roles (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	code varchar(50) NOT NULL,
	description text NULL,
	department_id int4 NULL,
	permissions jsonb NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_roles_code_key UNIQUE (code),
	CONSTRAINT efiling_roles_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_roles_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id)
);


-- public.efiling_sla_matrix definition

-- Drop table

-- DROP TABLE public.efiling_sla_matrix;

CREATE TABLE public.efiling_sla_matrix (
	id serial4 NOT NULL,
	from_role_code varchar(100) NOT NULL,
	to_role_code varchar(100) NOT NULL,
	level_scope varchar(20) DEFAULT 'district'::character varying NULL,
	sla_hours int4 DEFAULT 24 NULL,
	description text NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	department_id int4 NULL,
	CONSTRAINT efiling_sla_matrix_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_sla_matrix_unique UNIQUE (from_role_code, to_role_code),
	CONSTRAINT efiling_sla_matrix_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id) ON DELETE SET NULL
);
CREATE INDEX idx_efiling_sla_matrix_active ON public.efiling_sla_matrix USING btree (is_active) WHERE (is_active = true);
CREATE INDEX idx_efiling_sla_matrix_department ON public.efiling_sla_matrix USING btree (department_id);
CREATE INDEX idx_efiling_sla_matrix_from_role ON public.efiling_sla_matrix USING btree (from_role_code);
CREATE INDEX idx_efiling_sla_matrix_to_role ON public.efiling_sla_matrix USING btree (to_role_code);


-- public.efiling_sla_policies definition

-- Drop table

-- DROP TABLE public.efiling_sla_policies;

CREATE TABLE public.efiling_sla_policies (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	description text NULL,
	policy_type varchar(50) DEFAULT 'TIME_BASED'::character varying NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	department_id int4 NULL,
	CONSTRAINT efiling_sla_policies_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_sla_policies_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id) ON DELETE SET NULL
);
CREATE INDEX idx_efiling_sla_policies_department ON public.efiling_sla_policies USING btree (department_id);


-- public.town definition

-- Drop table

-- DROP TABLE public.town;

CREATE TABLE public.town (
	id serial4 NOT NULL,
	district_id int4 NULL,
	town varchar(255) NOT NULL,
	subtown varchar(255) NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT town_pkey PRIMARY KEY (id),
	CONSTRAINT town_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id)
);
CREATE INDEX idx_town_district_id ON public.town USING btree (district_id);


-- public.ce_user_districts definition

-- Drop table

-- DROP TABLE public.ce_user_districts;

CREATE TABLE public.ce_user_districts (
	id serial4 NOT NULL,
	ce_user_id int4 NOT NULL,
	district_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT ce_user_districts_pkey PRIMARY KEY (id),
	CONSTRAINT unique_ce_user_district UNIQUE (ce_user_id, district_id),
	CONSTRAINT ce_user_districts_ce_user_id_fkey FOREIGN KEY (ce_user_id) REFERENCES public.ce_users(id) ON DELETE CASCADE,
	CONSTRAINT ce_user_districts_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id) ON DELETE CASCADE
);
CREATE INDEX idx_ce_user_districts_ce_user ON public.ce_user_districts USING btree (ce_user_id);
CREATE INDEX idx_ce_user_districts_district ON public.ce_user_districts USING btree (district_id);


-- public.ce_user_towns definition

-- Drop table

-- DROP TABLE public.ce_user_towns;

CREATE TABLE public.ce_user_towns (
	id serial4 NOT NULL,
	ce_user_id int4 NOT NULL,
	town_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT ce_user_towns_pkey PRIMARY KEY (id),
	CONSTRAINT unique_ce_user_town UNIQUE (ce_user_id, town_id),
	CONSTRAINT ce_user_towns_ce_user_id_fkey FOREIGN KEY (ce_user_id) REFERENCES public.ce_users(id) ON DELETE CASCADE,
	CONSTRAINT ce_user_towns_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id) ON DELETE CASCADE
);
CREATE INDEX idx_ce_user_towns_ce_user ON public.ce_user_towns USING btree (ce_user_id);
CREATE INDEX idx_ce_user_towns_town ON public.ce_user_towns USING btree (town_id);


-- public.ce_user_zones definition

-- Drop table

-- DROP TABLE public.ce_user_zones;

CREATE TABLE public.ce_user_zones (
	id serial4 NOT NULL,
	ce_user_id int4 NOT NULL,
	zone_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT ce_user_zones_pkey PRIMARY KEY (id),
	CONSTRAINT unique_ce_user_zone UNIQUE (ce_user_id, zone_id),
	CONSTRAINT ce_user_zones_ce_user_id_fkey FOREIGN KEY (ce_user_id) REFERENCES public.ce_users(id) ON DELETE CASCADE,
	CONSTRAINT ce_user_zones_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id) ON DELETE CASCADE
);
CREATE INDEX idx_ce_user_zones_ce_user ON public.ce_user_zones USING btree (ce_user_id);
CREATE INDEX idx_ce_user_zones_zone ON public.ce_user_zones USING btree (zone_id);


-- public.divisions definition

-- Drop table

-- DROP TABLE public.divisions;

CREATE TABLE public.divisions (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	code varchar(50) NULL,
	ce_type varchar(100) NULL,
	department_id int4 NULL,
	description text NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT divisions_code_key UNIQUE (code),
	CONSTRAINT divisions_pkey PRIMARY KEY (id),
	CONSTRAINT divisions_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id)
);
CREATE INDEX idx_divisions_active ON public.divisions USING btree (is_active) WHERE (is_active = true);
CREATE INDEX idx_divisions_ce_type ON public.divisions USING btree (ce_type);
CREATE INDEX idx_divisions_department ON public.divisions USING btree (department_id);


-- public.efiling_department_locations definition

-- Drop table

-- DROP TABLE public.efiling_department_locations;

CREATE TABLE public.efiling_department_locations (
	id serial4 NOT NULL,
	department_id int4 NOT NULL,
	zone_id int4 NULL,
	district_id int4 NULL,
	town_id int4 NULL,
	division_id int4 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_department_locations_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_department_locations_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id) ON DELETE CASCADE,
	CONSTRAINT efiling_department_locations_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id),
	CONSTRAINT efiling_department_locations_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT efiling_department_locations_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id),
	CONSTRAINT efiling_department_locations_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id)
);
CREATE INDEX idx_department_locations_department ON public.efiling_department_locations USING btree (department_id);
CREATE INDEX idx_department_locations_zone_district ON public.efiling_department_locations USING btree (zone_id, district_id);


-- public.efiling_file_types definition

-- Drop table

-- DROP TABLE public.efiling_file_types;

CREATE TABLE public.efiling_file_types (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	code varchar(50) NOT NULL,
	description text NULL,
	category_id int4 NULL,
	department_id int4 NULL,
	can_create_roles jsonb NULL,
	requires_approval bool DEFAULT true NULL,
	max_approval_level int4 DEFAULT 5 NULL,
	sla_matrix_id int4 NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_file_types_code_key UNIQUE (code),
	CONSTRAINT efiling_file_types_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_file_types_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.efiling_file_categories(id),
	CONSTRAINT efiling_file_types_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id),
	CONSTRAINT efiling_file_types_sla_matrix_id_fkey FOREIGN KEY (sla_matrix_id) REFERENCES public.efiling_sla_matrix(id) ON DELETE SET NULL
);
CREATE INDEX idx_efiling_file_types_active ON public.efiling_file_types USING btree (id) WHERE (is_active = true);
CREATE INDEX idx_efiling_file_types_category ON public.efiling_file_types USING btree (category_id);
CREATE INDEX idx_efiling_file_types_department ON public.efiling_file_types USING btree (department_id);
CREATE INDEX idx_efiling_file_types_sla_matrix ON public.efiling_file_types USING btree (sla_matrix_id);


-- public.efiling_role_group_locations definition

-- Drop table

-- DROP TABLE public.efiling_role_group_locations;

CREATE TABLE public.efiling_role_group_locations (
	id serial4 NOT NULL,
	role_group_id int4 NOT NULL,
	zone_id int4 NULL,
	district_id int4 NULL,
	town_id int4 NULL,
	division_id int4 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_role_group_locations_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_role_group_locations_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id),
	CONSTRAINT efiling_role_group_locations_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT efiling_role_group_locations_role_group_id_fkey FOREIGN KEY (role_group_id) REFERENCES public.efiling_role_groups(id) ON DELETE CASCADE,
	CONSTRAINT efiling_role_group_locations_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id),
	CONSTRAINT efiling_role_group_locations_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id)
);
CREATE INDEX idx_role_group_locations_group ON public.efiling_role_group_locations USING btree (role_group_id);


-- public.efiling_role_group_members definition

-- Drop table

-- DROP TABLE public.efiling_role_group_members;

CREATE TABLE public.efiling_role_group_members (
	id serial4 NOT NULL,
	group_id int4 NOT NULL,
	role_id int4 NOT NULL,
	CONSTRAINT efiling_role_group_members_group_id_role_id_key UNIQUE (group_id, role_id),
	CONSTRAINT efiling_role_group_members_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_role_group_members_group_id_fkey FOREIGN KEY (group_id) REFERENCES public.efiling_role_groups(id) ON DELETE CASCADE,
	CONSTRAINT efiling_role_group_members_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.efiling_roles(id) ON DELETE CASCADE
);


-- public.efiling_role_locations definition

-- Drop table

-- DROP TABLE public.efiling_role_locations;

CREATE TABLE public.efiling_role_locations (
	id serial4 NOT NULL,
	role_id int4 NOT NULL,
	zone_id int4 NULL,
	district_id int4 NULL,
	town_id int4 NULL,
	division_id int4 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_role_locations_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_role_locations_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id),
	CONSTRAINT efiling_role_locations_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT efiling_role_locations_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.efiling_roles(id) ON DELETE CASCADE,
	CONSTRAINT efiling_role_locations_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id),
	CONSTRAINT efiling_role_locations_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id)
);
CREATE INDEX idx_role_locations_role ON public.efiling_role_locations USING btree (role_id);


-- public.efiling_zone_locations definition

-- Drop table

-- DROP TABLE public.efiling_zone_locations;

CREATE TABLE public.efiling_zone_locations (
	id serial4 NOT NULL,
	zone_id int4 NOT NULL,
	district_id int4 NULL,
	town_id int4 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_zone_locations_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_zone_locations_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id),
	CONSTRAINT efiling_zone_locations_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id),
	CONSTRAINT efiling_zone_locations_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX efiling_zone_locations_zone_id_town_id_idx ON public.efiling_zone_locations USING btree (zone_id, town_id);


-- public.subtown definition

-- Drop table

-- DROP TABLE public.subtown;

CREATE TABLE public.subtown (
	id serial4 NOT NULL,
	town_id int4 NULL,
	subtown varchar(255) NOT NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT subtown_pkey PRIMARY KEY (id),
	CONSTRAINT subtown_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id)
);
CREATE INDEX idx_subtown_town_id ON public.subtown USING btree (town_id);


-- public.ce_user_divisions definition

-- Drop table

-- DROP TABLE public.ce_user_divisions;

CREATE TABLE public.ce_user_divisions (
	id serial4 NOT NULL,
	ce_user_id int4 NOT NULL,
	division_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT ce_user_divisions_pkey PRIMARY KEY (id),
	CONSTRAINT unique_ce_user_division UNIQUE (ce_user_id, division_id),
	CONSTRAINT ce_user_divisions_ce_user_id_fkey FOREIGN KEY (ce_user_id) REFERENCES public.ce_users(id) ON DELETE CASCADE,
	CONSTRAINT ce_user_divisions_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id) ON DELETE CASCADE
);
CREATE INDEX idx_ce_user_divisions_ce_user ON public.ce_user_divisions USING btree (ce_user_id);
CREATE INDEX idx_ce_user_divisions_division ON public.ce_user_divisions USING btree (division_id);


-- public.complaint_types definition

-- Drop table

-- DROP TABLE public.complaint_types;

CREATE TABLE public.complaint_types (
	id serial4 NOT NULL,
	type_name varchar(255) NOT NULL,
	description text NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	efiling_department_id int4 NULL,
	division_id int4 NULL,
	CONSTRAINT complaint_types_pkey PRIMARY KEY (id),
	CONSTRAINT complaint_types_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id) ON DELETE SET NULL,
	CONSTRAINT complaint_types_efiling_department_id_fkey FOREIGN KEY (efiling_department_id) REFERENCES public.efiling_departments(id) ON DELETE SET NULL
);


-- public.efiling_users definition

-- Drop table

-- DROP TABLE public.efiling_users;

CREATE TABLE public.efiling_users (
	id serial4 NOT NULL,
	user_id int4 NULL,
	employee_id varchar(50) NULL,
	designation varchar(255) NULL,
	department_id int4 NULL,
	efiling_role_id int4 NULL,
	supervisor_id int4 NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	preferred_signature_method varchar(50) DEFAULT 'SMS_OTP'::character varying NULL,
	signature_settings jsonb DEFAULT '{"sms_enabled": true, "epen_enabled": true, "google_auth_enabled": true}'::jsonb NULL,
	approval_level int4 DEFAULT 1 NULL,
	approval_amount_limit numeric(15, 2) DEFAULT 0.00 NULL,
	can_sign bool DEFAULT true NULL,
	can_create_files bool DEFAULT true NULL,
	can_approve_files bool DEFAULT false NULL,
	can_reject_files bool DEFAULT false NULL,
	can_transfer_files bool DEFAULT true NULL,
	notification_preferences jsonb DEFAULT '{"sms": true, "email": true, "in_app": true}'::jsonb NULL,
	last_activity_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	is_available bool DEFAULT true NULL,
	max_concurrent_files int4 DEFAULT 10 NULL,
	current_file_count int4 DEFAULT 0 NULL,
	signature_template text DEFAULT 'Best regards,{name}'::text NULL,
	address text NULL,
	google_email varchar(255) NULL,
	is_consultant bool DEFAULT false NOT NULL,
	district_id int4 NULL,
	town_id int4 NULL,
	subtown_id int4 NULL,
	division_id int4 NULL,
	CONSTRAINT efiling_users_approval_level_check CHECK (((approval_level >= 1) AND (approval_level <= 5))),
	CONSTRAINT efiling_users_employee_id_key UNIQUE (employee_id),
	CONSTRAINT efiling_users_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_users_preferred_signature_method_check CHECK (((preferred_signature_method)::text = ANY (ARRAY[('SMS_OTP'::character varying)::text, ('GOOGLE_AUTH'::character varying)::text, ('E_PEN'::character varying)::text]))),
	CONSTRAINT efiling_users_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id),
	CONSTRAINT efiling_users_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id),
	CONSTRAINT efiling_users_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT efiling_users_efiling_role_id_fkey FOREIGN KEY (efiling_role_id) REFERENCES public.efiling_roles(id),
	CONSTRAINT efiling_users_subtown_id_fkey FOREIGN KEY (subtown_id) REFERENCES public.subtown(id),
	CONSTRAINT efiling_users_supervisor_id_fkey FOREIGN KEY (supervisor_id) REFERENCES public.efiling_users(id),
	CONSTRAINT efiling_users_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id),
	CONSTRAINT efiling_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE
);
CREATE INDEX idx_efiling_users_approval_level ON public.efiling_users USING btree (approval_level);
CREATE INDEX idx_efiling_users_available ON public.efiling_users USING btree (is_available, current_file_count);
CREATE INDEX idx_efiling_users_can_approve ON public.efiling_users USING btree (can_approve_files);
CREATE INDEX idx_efiling_users_department ON public.efiling_users USING btree (department_id);
CREATE INDEX idx_efiling_users_department_role ON public.efiling_users USING btree (department_id, efiling_role_id);
CREATE INDEX idx_efiling_users_district ON public.efiling_users USING btree (district_id);
CREATE INDEX idx_efiling_users_division ON public.efiling_users USING btree (division_id);
CREATE INDEX idx_efiling_users_is_consultant ON public.efiling_users USING btree (is_consultant);
CREATE INDEX idx_efiling_users_location ON public.efiling_users USING btree (district_id, town_id, division_id);
CREATE INDEX idx_efiling_users_role ON public.efiling_users USING btree (efiling_role_id);
CREATE INDEX idx_efiling_users_subtown ON public.efiling_users USING btree (subtown_id);
CREATE INDEX idx_efiling_users_town ON public.efiling_users USING btree (town_id);


-- public.agents definition

-- Drop table

-- DROP TABLE public.agents;

CREATE TABLE public.agents (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	designation varchar(255) NULL,
	contact_number varchar(50) NULL,
	address text NULL,
	department varchar(255) NULL,
	email varchar(255) NOT NULL,
	image varchar(250) NULL,
	"role" int4 NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	"password" varchar(255) NOT NULL,
	town_id int4 NULL,
	complaint_type_id int4 NULL,
	session_token varchar(255) NULL,
	division_id int4 NULL,
	company_name varchar(255) NULL,
	CONSTRAINT agents_email_key UNIQUE (email),
	CONSTRAINT agents_pkey PRIMARY KEY (id),
	CONSTRAINT agents_complaint_type_id_fkey FOREIGN KEY (complaint_type_id) REFERENCES public.complaint_types(id),
	CONSTRAINT agents_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT agents_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id)
);
CREATE INDEX idx_agents_division_id ON public.agents USING btree (division_id);
CREATE INDEX idx_agents_email ON public.agents USING btree (email);
CREATE INDEX idx_agents_role ON public.agents USING btree (role);
CREATE INDEX idx_agents_town_complaint ON public.agents USING btree (town_id, complaint_type_id);


-- public.ce_user_departments definition

-- Drop table

-- DROP TABLE public.ce_user_departments;

CREATE TABLE public.ce_user_departments (
	id serial4 NOT NULL,
	ce_user_id int4 NOT NULL,
	complaint_type_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT ce_user_departments_pkey PRIMARY KEY (id),
	CONSTRAINT ce_user_departments_unique UNIQUE (ce_user_id, complaint_type_id),
	CONSTRAINT ce_user_departments_ce_user_id_fkey FOREIGN KEY (ce_user_id) REFERENCES public.ce_users(id) ON DELETE CASCADE,
	CONSTRAINT ce_user_departments_complaint_type_id_fkey FOREIGN KEY (complaint_type_id) REFERENCES public.complaint_types(id) ON DELETE CASCADE
);
CREATE INDEX idx_ce_user_departments_ce_user_id ON public.ce_user_departments USING btree (ce_user_id);
CREATE INDEX idx_ce_user_departments_complaint_type_id ON public.ce_user_departments USING btree (complaint_type_id);


-- public.complaint_subtypes definition

-- Drop table

-- DROP TABLE public.complaint_subtypes;

CREATE TABLE public.complaint_subtypes (
	id serial4 NOT NULL,
	subtype_name varchar(255) NOT NULL,
	complaint_type_id int4 NULL,
	description text NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT complaint_subtypes_pkey PRIMARY KEY (id),
	CONSTRAINT complaint_subtypes_complaint_type_id_fkey FOREIGN KEY (complaint_type_id) REFERENCES public.complaint_types(id) ON DELETE CASCADE
);


-- public.complaint_type_divisions definition

-- Drop table

-- DROP TABLE public.complaint_type_divisions;

CREATE TABLE public.complaint_type_divisions (
	id serial4 NOT NULL,
	complaint_type_id int4 NOT NULL,
	division_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT complaint_type_divisions_pkey PRIMARY KEY (id),
	CONSTRAINT unique_complaint_type_division UNIQUE (complaint_type_id, division_id),
	CONSTRAINT complaint_type_divisions_complaint_type_id_fkey FOREIGN KEY (complaint_type_id) REFERENCES public.complaint_types(id) ON DELETE CASCADE,
	CONSTRAINT complaint_type_divisions_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id) ON DELETE CASCADE
);
CREATE INDEX idx_complaint_type_divisions_complaint_type ON public.complaint_type_divisions USING btree (complaint_type_id);
CREATE INDEX idx_complaint_type_divisions_division ON public.complaint_type_divisions USING btree (division_id);


-- public.efiling_daak definition

-- Drop table

-- DROP TABLE public.efiling_daak;

CREATE TABLE public.efiling_daak (
	id serial4 NOT NULL,
	daak_number varchar(100) NOT NULL,
	subject varchar(500) NOT NULL,
	"content" text NOT NULL,
	category_id int4 NULL,
	priority varchar(20) DEFAULT 'NORMAL'::character varying NULL,
	created_by int4 NOT NULL,
	department_id int4 NULL,
	role_id int4 NULL,
	is_urgent bool DEFAULT false NULL,
	is_public bool DEFAULT false NULL,
	expires_at timestamp NULL,
	status varchar(20) DEFAULT 'DRAFT'::character varying NULL,
	sent_at timestamp NULL,
	total_recipients int4 DEFAULT 0 NULL,
	acknowledged_count int4 DEFAULT 0 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_daak_daak_number_key UNIQUE (daak_number),
	CONSTRAINT efiling_daak_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_daak_priority_check CHECK (((priority)::text = ANY ((ARRAY['LOW'::character varying, 'NORMAL'::character varying, 'HIGH'::character varying, 'URGENT'::character varying])::text[]))),
	CONSTRAINT efiling_daak_status_check CHECK (((status)::text = ANY ((ARRAY['DRAFT'::character varying, 'SENT'::character varying, 'CANCELLED'::character varying])::text[]))),
	CONSTRAINT efiling_daak_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.efiling_daak_categories(id),
	CONSTRAINT efiling_daak_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.efiling_users(id) ON DELETE RESTRICT,
	CONSTRAINT efiling_daak_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id),
	CONSTRAINT efiling_daak_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.efiling_roles(id)
);
CREATE INDEX idx_daak_category ON public.efiling_daak USING btree (category_id);
CREATE INDEX idx_daak_created_at ON public.efiling_daak USING btree (created_at DESC);
CREATE INDEX idx_daak_created_by ON public.efiling_daak USING btree (created_by);
CREATE INDEX idx_daak_expires ON public.efiling_daak USING btree (expires_at) WHERE (expires_at IS NOT NULL);
CREATE INDEX idx_daak_priority ON public.efiling_daak USING btree (priority);
CREATE INDEX idx_daak_public ON public.efiling_daak USING btree (is_public) WHERE (is_public = true);
CREATE INDEX idx_daak_status ON public.efiling_daak USING btree (status);

-- Table Triggers

create trigger trigger_efiling_daak_updated_at before
update
    on
    public.efiling_daak for each row execute function update_updated_at_column();


-- public.efiling_daak_acknowledgments definition

-- Drop table

-- DROP TABLE public.efiling_daak_acknowledgments;

CREATE TABLE public.efiling_daak_acknowledgments (
	id serial4 NOT NULL,
	daak_id int4 NOT NULL,
	recipient_id int4 NOT NULL,
	acknowledgment_text text NULL,
	acknowledged_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	ip_address varchar(45) NULL,
	user_agent text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_daak_acknowledgments_pkey PRIMARY KEY (id),
	CONSTRAINT unique_daak_user_acknowledgment UNIQUE (daak_id, recipient_id),
	CONSTRAINT efiling_daak_acknowledgments_daak_id_fkey FOREIGN KEY (daak_id) REFERENCES public.efiling_daak(id) ON DELETE CASCADE,
	CONSTRAINT efiling_daak_acknowledgments_recipient_id_fkey FOREIGN KEY (recipient_id) REFERENCES public.efiling_users(id) ON DELETE CASCADE
);
CREATE INDEX idx_daak_ack_daak ON public.efiling_daak_acknowledgments USING btree (daak_id);
CREATE INDEX idx_daak_ack_date ON public.efiling_daak_acknowledgments USING btree (acknowledged_at DESC);
CREATE INDEX idx_daak_ack_user ON public.efiling_daak_acknowledgments USING btree (recipient_id);


-- public.efiling_daak_attachments definition

-- Drop table

-- DROP TABLE public.efiling_daak_attachments;

CREATE TABLE public.efiling_daak_attachments (
	id serial4 NOT NULL,
	daak_id int4 NOT NULL,
	file_name varchar(500) NOT NULL,
	file_path varchar(1000) NOT NULL,
	file_size int8 NULL,
	file_type varchar(100) NULL,
	uploaded_by int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_daak_attachments_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_daak_attachments_daak_id_fkey FOREIGN KEY (daak_id) REFERENCES public.efiling_daak(id) ON DELETE CASCADE,
	CONSTRAINT efiling_daak_attachments_uploaded_by_fkey FOREIGN KEY (uploaded_by) REFERENCES public.efiling_users(id) ON DELETE RESTRICT
);
CREATE INDEX idx_daak_attachments_daak ON public.efiling_daak_attachments USING btree (daak_id);
CREATE INDEX idx_daak_attachments_uploaded_by ON public.efiling_daak_attachments USING btree (uploaded_by);


-- public.efiling_daak_recipients definition

-- Drop table

-- DROP TABLE public.efiling_daak_recipients;

CREATE TABLE public.efiling_daak_recipients (
	id serial4 NOT NULL,
	daak_id int4 NOT NULL,
	recipient_type varchar(20) NOT NULL,
	recipient_id int4 NULL,
	efiling_user_id int4 NULL,
	status varchar(20) DEFAULT 'PENDING'::character varying NULL,
	received_at timestamp NULL,
	acknowledged_at timestamp NULL,
	read_at timestamp NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_daak_recipients_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_daak_recipients_recipient_type_check CHECK (((recipient_type)::text = ANY ((ARRAY['USER'::character varying, 'ROLE'::character varying, 'ROLE_GROUP'::character varying, 'TEAM'::character varying, 'DEPARTMENT'::character varying, 'EVERYONE'::character varying])::text[]))),
	CONSTRAINT efiling_daak_recipients_status_check CHECK (((status)::text = ANY ((ARRAY['PENDING'::character varying, 'SENT'::character varying, 'RECEIVED'::character varying, 'ACKNOWLEDGED'::character varying])::text[]))),
	CONSTRAINT unique_daak_user_recipient UNIQUE (daak_id, efiling_user_id),
	CONSTRAINT efiling_daak_recipients_daak_id_fkey FOREIGN KEY (daak_id) REFERENCES public.efiling_daak(id) ON DELETE CASCADE,
	CONSTRAINT efiling_daak_recipients_efiling_user_id_fkey FOREIGN KEY (efiling_user_id) REFERENCES public.efiling_users(id) ON DELETE CASCADE
);
CREATE INDEX idx_daak_recipients_acknowledged ON public.efiling_daak_recipients USING btree (daak_id, acknowledged_at) WHERE (acknowledged_at IS NOT NULL);
CREATE INDEX idx_daak_recipients_daak ON public.efiling_daak_recipients USING btree (daak_id);
CREATE INDEX idx_daak_recipients_status ON public.efiling_daak_recipients USING btree (status);
CREATE INDEX idx_daak_recipients_type ON public.efiling_daak_recipients USING btree (recipient_type, recipient_id);
CREATE INDEX idx_daak_recipients_user ON public.efiling_daak_recipients USING btree (efiling_user_id);

-- Table Triggers

create trigger trigger_efiling_daak_recipients_updated_at before
update
    on
    public.efiling_daak_recipients for each row execute function update_updated_at_column();


-- public.efiling_meeting_settings definition

-- Drop table

-- DROP TABLE public.efiling_meeting_settings;

CREATE TABLE public.efiling_meeting_settings (
	id serial4 NOT NULL,
	setting_key varchar(100) NOT NULL,
	setting_value jsonb NOT NULL,
	description text NULL,
	updated_by int4 NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_meeting_settings_key_key UNIQUE (setting_key),
	CONSTRAINT efiling_meeting_settings_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_meeting_settings_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.efiling_users(id)
);
CREATE INDEX idx_meeting_settings_key ON public.efiling_meeting_settings USING btree (setting_key);

-- Table Triggers

create trigger trigger_efiling_meeting_settings_updated_at before
update
    on
    public.efiling_meeting_settings for each row execute function update_updated_at_column();


-- public.efiling_meetings definition

-- Drop table

-- DROP TABLE public.efiling_meetings;

CREATE TABLE public.efiling_meetings (
	id serial4 NOT NULL,
	meeting_number varchar(100) NOT NULL,
	title varchar(500) NOT NULL,
	description text NULL,
	agenda text NULL,
	meeting_type varchar(20) DEFAULT 'IN_PERSON'::character varying NULL,
	meeting_date date NOT NULL,
	start_time time NOT NULL,
	end_time time NOT NULL,
	duration_minutes int4 NULL,
	venue_address varchar(500) NULL,
	meeting_link varchar(1000) NULL,
	organizer_id int4 NOT NULL,
	department_id int4 NULL,
	status varchar(20) DEFAULT 'SCHEDULED'::character varying NULL,
	is_recurring bool DEFAULT false NULL,
	recurrence_pattern jsonb NULL,
	reminder_sent bool DEFAULT false NULL,
	reminder_sent_at timestamp NULL,
	total_attendees int4 DEFAULT 0 NULL,
	accepted_count int4 DEFAULT 0 NULL,
	present_count int4 DEFAULT 0 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	started_at timestamp NULL,
	ended_at timestamp NULL,
	CONSTRAINT efiling_meetings_meeting_number_key UNIQUE (meeting_number),
	CONSTRAINT efiling_meetings_meeting_type_check CHECK (((meeting_type)::text = ANY ((ARRAY['IN_PERSON'::character varying, 'VIRTUAL'::character varying, 'HYBRID'::character varying])::text[]))),
	CONSTRAINT efiling_meetings_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_meetings_status_check CHECK (((status)::text = ANY ((ARRAY['SCHEDULED'::character varying, 'ONGOING'::character varying, 'COMPLETED'::character varying, 'CANCELLED'::character varying, 'POSTPONED'::character varying])::text[]))),
	CONSTRAINT efiling_meetings_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id),
	CONSTRAINT efiling_meetings_organizer_id_fkey FOREIGN KEY (organizer_id) REFERENCES public.efiling_users(id) ON DELETE RESTRICT
);
CREATE INDEX idx_meetings_created_at ON public.efiling_meetings USING btree (created_at DESC);
CREATE INDEX idx_meetings_date ON public.efiling_meetings USING btree (meeting_date, start_time);
CREATE INDEX idx_meetings_organizer ON public.efiling_meetings USING btree (organizer_id);
CREATE INDEX idx_meetings_recurring ON public.efiling_meetings USING btree (is_recurring) WHERE (is_recurring = true);
CREATE INDEX idx_meetings_status ON public.efiling_meetings USING btree (status);
CREATE INDEX idx_meetings_type ON public.efiling_meetings USING btree (meeting_type);

-- Table Triggers

create trigger trigger_efiling_meetings_updated_at before
update
    on
    public.efiling_meetings for each row execute function update_updated_at_column();


-- public.efiling_permission_audit_log definition

-- Drop table

-- DROP TABLE public.efiling_permission_audit_log;

CREATE TABLE public.efiling_permission_audit_log (
	id serial4 NOT NULL,
	user_id int4 NOT NULL,
	"action" varchar(100) NOT NULL,
	permission_type varchar(100) NOT NULL,
	target_user_id int4 NULL,
	target_role_id int4 NULL,
	permission_details jsonb NULL,
	ip_address inet NULL,
	user_agent text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_permission_audit_log_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_permission_audit_log_target_role_id_fkey FOREIGN KEY (target_role_id) REFERENCES public.efiling_roles(id),
	CONSTRAINT efiling_permission_audit_log_target_user_id_fkey FOREIGN KEY (target_user_id) REFERENCES public.efiling_users(id),
	CONSTRAINT efiling_permission_audit_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.efiling_users(id)
);
CREATE INDEX idx_efiling_permission_audit_log_created_at ON public.efiling_permission_audit_log USING btree (created_at);
CREATE INDEX idx_efiling_permission_audit_log_user ON public.efiling_permission_audit_log USING btree (user_id);


-- public.efiling_role_permissions definition

-- Drop table

-- DROP TABLE public.efiling_role_permissions;

CREATE TABLE public.efiling_role_permissions (
	id serial4 NOT NULL,
	role_id int4 NOT NULL,
	permission_id int4 NOT NULL,
	"granted" bool DEFAULT true NULL,
	conditions jsonb NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	granted_by int4 NULL,
	CONSTRAINT efiling_role_permissions_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_role_permissions_unique UNIQUE (role_id, permission_id),
	CONSTRAINT efiling_role_permissions_granted_by_fkey FOREIGN KEY (granted_by) REFERENCES public.efiling_users(id),
	CONSTRAINT efiling_role_permissions_permission_id_fkey FOREIGN KEY (permission_id) REFERENCES public.efiling_permissions(id) ON DELETE CASCADE,
	CONSTRAINT efiling_role_permissions_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.efiling_roles(id) ON DELETE CASCADE
);
CREATE INDEX idx_efiling_role_permissions_permission ON public.efiling_role_permissions USING btree (permission_id);
CREATE INDEX idx_efiling_role_permissions_role ON public.efiling_role_permissions USING btree (role_id);


-- public.efiling_templates definition

-- Drop table

-- DROP TABLE public.efiling_templates;

CREATE TABLE public.efiling_templates (
	id serial4 NOT NULL,
	"name" varchar(255) NOT NULL,
	category_id int4 NULL,
	template_content text NULL,
	variables jsonb NULL,
	created_by int4 NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	template_type varchar(50) NULL,
	title varchar(500) NULL,
	subject text NULL,
	main_content text NULL,
	department_id int4 NULL,
	role_id int4 NULL,
	is_system_template bool DEFAULT false NULL,
	usage_count int4 DEFAULT 0 NULL,
	last_used_at timestamp NULL,
	CONSTRAINT check_template_content CHECK ((((title IS NOT NULL) AND ((title)::text <> ''::text)) OR ((subject IS NOT NULL) AND (subject <> ''::text)) OR ((main_content IS NOT NULL) AND (main_content <> ''::text)))),
	CONSTRAINT efiling_templates_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_templates_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.efiling_file_categories(id),
	CONSTRAINT efiling_templates_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.efiling_users(id),
	CONSTRAINT efiling_templates_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id) ON DELETE SET NULL,
	CONSTRAINT efiling_templates_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.efiling_roles(id) ON DELETE SET NULL
);
CREATE INDEX idx_efiling_templates_active ON public.efiling_templates USING btree (is_active) WHERE (is_active = true);
CREATE INDEX idx_efiling_templates_created_by ON public.efiling_templates USING btree (created_by);
CREATE INDEX idx_efiling_templates_department ON public.efiling_templates USING btree (department_id);
CREATE INDEX idx_efiling_templates_department_role ON public.efiling_templates USING btree (department_id, role_id);
CREATE INDEX idx_efiling_templates_role ON public.efiling_templates USING btree (role_id);
CREATE INDEX idx_efiling_templates_type ON public.efiling_templates USING btree (template_type);

-- Table Triggers

create trigger trigger_update_efiling_templates_updated_at before
update
    on
    public.efiling_templates for each row execute function update_efiling_templates_updated_at();


-- public.efiling_user_teams definition

-- Drop table

-- DROP TABLE public.efiling_user_teams;

CREATE TABLE public.efiling_user_teams (
	id serial4 NOT NULL,
	manager_id int4 NOT NULL,
	team_member_id int4 NOT NULL,
	team_role varchar(50) NOT NULL,
	is_active bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT check_not_self_reference CHECK ((manager_id <> team_member_id)),
	CONSTRAINT efiling_user_teams_pkey PRIMARY KEY (id),
	CONSTRAINT unique_team_member UNIQUE (manager_id, team_member_id),
	CONSTRAINT efiling_user_teams_manager_id_fkey FOREIGN KEY (manager_id) REFERENCES public.efiling_users(id) ON DELETE CASCADE,
	CONSTRAINT efiling_user_teams_team_member_id_fkey FOREIGN KEY (team_member_id) REFERENCES public.efiling_users(id) ON DELETE CASCADE
);
CREATE INDEX idx_team_active ON public.efiling_user_teams USING btree (manager_id, is_active) WHERE (is_active = true);
CREATE INDEX idx_team_manager ON public.efiling_user_teams USING btree (manager_id);
CREATE INDEX idx_team_member ON public.efiling_user_teams USING btree (team_member_id);

-- Table Triggers

create trigger trigger_update_team_updated_at before
update
    on
    public.efiling_user_teams for each row execute function update_team_updated_at();


-- public.efiling_user_tools definition

-- Drop table

-- DROP TABLE public.efiling_user_tools;

CREATE TABLE public.efiling_user_tools (
	id serial4 NOT NULL,
	user_id int4 NULL,
	tool_id int4 NULL,
	can_use bool DEFAULT true NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_user_tools_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_user_tools_user_id_tool_id_key UNIQUE (user_id, tool_id),
	CONSTRAINT efiling_user_tools_tool_id_fkey FOREIGN KEY (tool_id) REFERENCES public.efiling_tools(id),
	CONSTRAINT efiling_user_tools_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.efiling_users(id)
);


-- public.notifications definition

-- Drop table

-- DROP TABLE public.notifications;

CREATE TABLE public.notifications (
	id serial4 NOT NULL,
	user_id int4 NULL,
	"type" varchar(32) NOT NULL,
	entity_id int4 NOT NULL,
	message text NOT NULL,
	created_at timestamp DEFAULT now() NULL,
	"read" bool DEFAULT false NULL,
	agent_id int4 NULL,
	socialmedia_id int4 NULL,
	CONSTRAINT notifications_pkey PRIMARY KEY (id),
	CONSTRAINT fk_notifications_agent FOREIGN KEY (agent_id) REFERENCES public.agents(id),
	CONSTRAINT fk_notifications_socialmedia FOREIGN KEY (socialmedia_id) REFERENCES public.socialmediaperson(id),
	CONSTRAINT fk_notifications_user FOREIGN KEY (user_id) REFERENCES public.users(id)
);
CREATE INDEX idx_notifications_read ON public.notifications USING btree (user_id, read);
CREATE INDEX idx_notifications_user_id ON public.notifications USING btree (user_id);


-- public.work_requests definition

-- Drop table

-- DROP TABLE public.work_requests;

CREATE TABLE public.work_requests (
	id serial4 NOT NULL,
	request_date date DEFAULT CURRENT_DATE NOT NULL,
	town_id int4 NULL,
	subtown_id int4 NULL,
	complaint_type_id int4 NOT NULL,
	complaint_subtype_id int4 NULL,
	contact_number varchar(20) NOT NULL,
	address text NOT NULL,
	description text NOT NULL,
	applicant_id int4 NULL,
	status_id int4 DEFAULT 1 NOT NULL,
	assigned_to int4 NULL,
	created_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	geo_tag public.geometry NULL,
	creator_id int4 NULL,
	creator_type varchar(20) NULL,
	budget_code varchar(100) NULL,
	file_type varchar(30) NULL,
	executive_engineer_id int4 NULL,
	contractor_id int4 NULL,
	nature_of_work varchar(255) DEFAULT NULL::character varying NULL,
	division_id int4 NULL,
	zone_id int4 NULL,
	CONSTRAINT chk_file_type CHECK (((file_type)::text = ANY ((ARRAY['SPI'::character varying, 'R&M'::character varying, 'ADP'::character varying])::text[]))),
	CONSTRAINT work_requests_pkey PRIMARY KEY (id),
	CONSTRAINT work_requests_town_or_division_chk CHECK ((((town_id IS NOT NULL) AND (division_id IS NULL)) OR ((town_id IS NULL) AND (division_id IS NOT NULL)))),
	CONSTRAINT work_requests_applicant_id_fkey FOREIGN KEY (applicant_id) REFERENCES public.users(id),
	CONSTRAINT work_requests_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.users(id),
	CONSTRAINT work_requests_complaint_subtype_id_fkey FOREIGN KEY (complaint_subtype_id) REFERENCES public.complaint_subtypes(id),
	CONSTRAINT work_requests_complaint_type_id_fkey FOREIGN KEY (complaint_type_id) REFERENCES public.complaint_types(id),
	CONSTRAINT work_requests_contractor_id_fkey FOREIGN KEY (contractor_id) REFERENCES public.agents(id),
	CONSTRAINT work_requests_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT work_requests_executive_engineer_id_fkey FOREIGN KEY (executive_engineer_id) REFERENCES public.agents(id),
	CONSTRAINT work_requests_status_id_fkey FOREIGN KEY (status_id) REFERENCES public.status(id),
	CONSTRAINT work_requests_subtown_id_fkey FOREIGN KEY (subtown_id) REFERENCES public.subtown(id),
	CONSTRAINT work_requests_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id),
	CONSTRAINT work_requests_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id)
);
CREATE INDEX idx_work_requests_assigned_to ON public.work_requests USING btree (assigned_to);
CREATE INDEX idx_work_requests_complaint_subtype_id ON public.work_requests USING btree (complaint_subtype_id);
CREATE INDEX idx_work_requests_complaint_type_id ON public.work_requests USING btree (complaint_type_id);
CREATE INDEX idx_work_requests_contractor ON public.work_requests USING btree (contractor_id);
CREATE INDEX idx_work_requests_creator ON public.work_requests USING btree (creator_id, creator_type);
CREATE INDEX idx_work_requests_division ON public.work_requests USING btree (division_id);
CREATE INDEX idx_work_requests_exec_engineer ON public.work_requests USING btree (executive_engineer_id);
CREATE INDEX idx_work_requests_request_date ON public.work_requests USING btree (request_date);
CREATE INDEX idx_work_requests_status_id ON public.work_requests USING btree (status_id);
CREATE INDEX idx_work_requests_town_id ON public.work_requests USING btree (town_id);
CREATE INDEX idx_work_requests_zone ON public.work_requests USING btree (zone_id);

-- Table Triggers

create trigger refresh_dashboard_on_work_requests_change after
insert
    or
delete
    or
update
    on
    public.work_requests for each statement execute function trigger_refresh_dashboard_view();


-- public.before_content definition

-- Drop table

-- DROP TABLE public.before_content;

CREATE TABLE public.before_content (
	id int4 DEFAULT nextval('before_images_id_seq'::regclass) NOT NULL,
	link text NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	work_request_id int4 NULL,
	description text NULL,
	geo_tag public.geometry NULL,
	creator_id int4 NULL,
	creator_type varchar(20) NULL,
	creator_name text NULL,
	content_type varchar(10) DEFAULT 'image'::character varying NOT NULL,
	file_name text NULL,
	file_size int8 NULL,
	file_type text NULL,
	division_id int4 NULL,
	zone_id int4 NULL,
	CONSTRAINT before_images_pkey PRIMARY KEY (id),
	CONSTRAINT check_content_type CHECK (((content_type)::text = ANY ((ARRAY['image'::character varying, 'video'::character varying])::text[]))),
	CONSTRAINT before_content_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT before_content_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id),
	CONSTRAINT before_images_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE
);
CREATE INDEX idx_before_content_division_zone ON public.before_content USING btree (division_id, zone_id);
CREATE INDEX idx_before_images_creator ON public.before_content USING btree (creator_id, creator_type);
CREATE INDEX idx_before_images_work_request_id ON public.before_content USING btree (work_request_id);

-- Table Triggers

create trigger refresh_dashboard_on_before_images_change after
insert
    or
delete
    or
update
    on
    public.before_content for each statement execute function trigger_refresh_dashboard_view();


-- public.efiling_meeting_attachments definition

-- Drop table

-- DROP TABLE public.efiling_meeting_attachments;

CREATE TABLE public.efiling_meeting_attachments (
	id serial4 NOT NULL,
	meeting_id int4 NOT NULL,
	file_name varchar(500) NOT NULL,
	file_path varchar(1000) NOT NULL,
	file_size int8 NULL,
	file_type varchar(100) NULL,
	attachment_type varchar(50) DEFAULT 'DOCUMENT'::character varying NULL,
	uploaded_by int4 NOT NULL,
	description text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_meeting_attachments_attachment_type_check CHECK (((attachment_type)::text = ANY ((ARRAY['AGENDA'::character varying, 'DOCUMENT'::character varying, 'PRESENTATION'::character varying, 'OTHER'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_attachments_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_meeting_attachments_meeting_id_fkey FOREIGN KEY (meeting_id) REFERENCES public.efiling_meetings(id) ON DELETE CASCADE,
	CONSTRAINT efiling_meeting_attachments_uploaded_by_fkey FOREIGN KEY (uploaded_by) REFERENCES public.efiling_users(id) ON DELETE RESTRICT
);
CREATE INDEX idx_meeting_attachments_meeting ON public.efiling_meeting_attachments USING btree (meeting_id);
CREATE INDEX idx_meeting_attachments_type ON public.efiling_meeting_attachments USING btree (attachment_type);
CREATE INDEX idx_meeting_attachments_uploaded_by ON public.efiling_meeting_attachments USING btree (uploaded_by);


-- public.efiling_meeting_attendees definition

-- Drop table

-- DROP TABLE public.efiling_meeting_attendees;

CREATE TABLE public.efiling_meeting_attendees (
	id serial4 NOT NULL,
	meeting_id int4 NOT NULL,
	attendee_id int4 NOT NULL,
	attendee_type varchar(20) DEFAULT 'USER'::character varying NULL,
	source_id int4 NULL,
	response_status varchar(20) DEFAULT 'PENDING'::character varying NULL,
	attendance_status varchar(20) NULL,
	responded_at timestamp NULL,
	attended_at timestamp NULL,
	left_at timestamp NULL,
	notes text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_meeting_attendees_attendance_status_check CHECK (((attendance_status)::text = ANY ((ARRAY['PRESENT'::character varying, 'ABSENT'::character varying, 'LATE'::character varying, 'LEFT_EARLY'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_attendees_attendee_type_check CHECK (((attendee_type)::text = ANY ((ARRAY['USER'::character varying, 'ROLE'::character varying, 'ROLE_GROUP'::character varying, 'TEAM'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_attendees_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_meeting_attendees_response_status_check CHECK (((response_status)::text = ANY ((ARRAY['PENDING'::character varying, 'ACCEPTED'::character varying, 'DECLINED'::character varying, 'TENTATIVE'::character varying])::text[]))),
	CONSTRAINT unique_meeting_user_attendee UNIQUE (meeting_id, attendee_id),
	CONSTRAINT efiling_meeting_attendees_attendee_id_fkey FOREIGN KEY (attendee_id) REFERENCES public.efiling_users(id) ON DELETE CASCADE,
	CONSTRAINT efiling_meeting_attendees_meeting_id_fkey FOREIGN KEY (meeting_id) REFERENCES public.efiling_meetings(id) ON DELETE CASCADE
);
CREATE INDEX idx_meeting_attendees_attendance ON public.efiling_meeting_attendees USING btree (attendance_status);
CREATE INDEX idx_meeting_attendees_meeting ON public.efiling_meeting_attendees USING btree (meeting_id);
CREATE INDEX idx_meeting_attendees_response ON public.efiling_meeting_attendees USING btree (response_status);
CREATE INDEX idx_meeting_attendees_type ON public.efiling_meeting_attendees USING btree (attendee_type, source_id);
CREATE INDEX idx_meeting_attendees_user ON public.efiling_meeting_attendees USING btree (attendee_id);

-- Table Triggers

create trigger trigger_efiling_meeting_attendees_updated_at before
update
    on
    public.efiling_meeting_attendees for each row execute function update_updated_at_column();


-- public.efiling_meeting_external_attendees definition

-- Drop table

-- DROP TABLE public.efiling_meeting_external_attendees;

CREATE TABLE public.efiling_meeting_external_attendees (
	id serial4 NOT NULL,
	meeting_id int4 NOT NULL,
	email varchar(255) NOT NULL,
	"name" varchar(255) NOT NULL,
	designation varchar(255) NULL,
	organization varchar(255) NULL,
	response_status varchar(20) DEFAULT 'PENDING'::character varying NULL,
	attendance_status varchar(20) NULL,
	invitation_sent bool DEFAULT false NULL,
	invitation_sent_at timestamp NULL,
	email_sent_count int4 DEFAULT 0 NULL,
	responded_at timestamp NULL,
	responded_via varchar(20) NULL,
	response_token varchar(100) NULL,
	attended_at timestamp NULL,
	left_at timestamp NULL,
	notes text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_meeting_external_attendees_attendance_status_check CHECK (((attendance_status)::text = ANY ((ARRAY['PRESENT'::character varying, 'ABSENT'::character varying, 'LATE'::character varying, 'LEFT_EARLY'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_external_attendees_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_meeting_external_attendees_responded_via_check CHECK (((responded_via)::text = ANY ((ARRAY['EMAIL_LINK'::character varying, 'EMAIL_REPLY'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_external_attendees_response_status_check CHECK (((response_status)::text = ANY ((ARRAY['PENDING'::character varying, 'ACCEPTED'::character varying, 'DECLINED'::character varying, 'TENTATIVE'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_external_attendees_response_token_key UNIQUE (response_token),
	CONSTRAINT unique_meeting_external_email UNIQUE (meeting_id, email),
	CONSTRAINT efiling_meeting_external_attendees_meeting_id_fkey FOREIGN KEY (meeting_id) REFERENCES public.efiling_meetings(id) ON DELETE CASCADE
);
CREATE INDEX idx_meeting_external_email ON public.efiling_meeting_external_attendees USING btree (email);
CREATE INDEX idx_meeting_external_meeting ON public.efiling_meeting_external_attendees USING btree (meeting_id);
CREATE INDEX idx_meeting_external_response ON public.efiling_meeting_external_attendees USING btree (response_status);
CREATE INDEX idx_meeting_external_sent ON public.efiling_meeting_external_attendees USING btree (invitation_sent) WHERE (invitation_sent = true);
CREATE INDEX idx_meeting_external_token ON public.efiling_meeting_external_attendees USING btree (response_token) WHERE (response_token IS NOT NULL);

-- Table Triggers

create trigger trigger_efiling_meeting_external_attendees_updated_at before
update
    on
    public.efiling_meeting_external_attendees for each row execute function update_updated_at_column();


-- public.efiling_meeting_reminders definition

-- Drop table

-- DROP TABLE public.efiling_meeting_reminders;

CREATE TABLE public.efiling_meeting_reminders (
	id serial4 NOT NULL,
	meeting_id int4 NOT NULL,
	attendee_id int4 NULL,
	external_email varchar(255) NULL,
	reminder_type varchar(20) NOT NULL,
	reminder_sent_at timestamp NULL,
	reminder_sent_status varchar(20) NULL,
	reminder_minutes_before int4 NOT NULL,
	error_message text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT check_attendee_or_email CHECK ((((attendee_id IS NOT NULL) AND (external_email IS NULL)) OR ((attendee_id IS NULL) AND (external_email IS NOT NULL)))),
	CONSTRAINT efiling_meeting_reminders_pkey PRIMARY KEY (id),
	CONSTRAINT efiling_meeting_reminders_reminder_sent_status_check CHECK (((reminder_sent_status)::text = ANY ((ARRAY['SUCCESS'::character varying, 'FAILED'::character varying, 'PENDING'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_reminders_reminder_type_check CHECK (((reminder_type)::text = ANY ((ARRAY['EMAIL'::character varying, 'SMS'::character varying, 'IN_APP'::character varying])::text[]))),
	CONSTRAINT efiling_meeting_reminders_attendee_id_fkey FOREIGN KEY (attendee_id) REFERENCES public.efiling_users(id) ON DELETE CASCADE,
	CONSTRAINT efiling_meeting_reminders_meeting_id_fkey FOREIGN KEY (meeting_id) REFERENCES public.efiling_meetings(id) ON DELETE CASCADE
);
CREATE INDEX idx_meeting_reminders_attendee ON public.efiling_meeting_reminders USING btree (attendee_id) WHERE (attendee_id IS NOT NULL);
CREATE INDEX idx_meeting_reminders_email ON public.efiling_meeting_reminders USING btree (external_email) WHERE (external_email IS NOT NULL);
CREATE INDEX idx_meeting_reminders_meeting ON public.efiling_meeting_reminders USING btree (meeting_id);
CREATE INDEX idx_meeting_reminders_sent_at ON public.efiling_meeting_reminders USING btree (reminder_sent_at) WHERE (reminder_sent_at IS NOT NULL);
CREATE INDEX idx_meeting_reminders_status ON public.efiling_meeting_reminders USING btree (reminder_sent_status);


-- public.efiling_template_departments definition

-- Drop table

-- DROP TABLE public.efiling_template_departments;

CREATE TABLE public.efiling_template_departments (
	id serial4 NOT NULL,
	template_id int4 NOT NULL,
	department_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_template_departments_pkey PRIMARY KEY (id),
	CONSTRAINT unique_template_department UNIQUE (template_id, department_id),
	CONSTRAINT efiling_template_departments_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id) ON DELETE CASCADE,
	CONSTRAINT efiling_template_departments_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.efiling_templates(id) ON DELETE CASCADE
);
CREATE INDEX idx_template_departments_department ON public.efiling_template_departments USING btree (department_id);
CREATE INDEX idx_template_departments_template ON public.efiling_template_departments USING btree (template_id);


-- public.efiling_template_roles definition

-- Drop table

-- DROP TABLE public.efiling_template_roles;

CREATE TABLE public.efiling_template_roles (
	id serial4 NOT NULL,
	template_id int4 NOT NULL,
	role_id int4 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_template_roles_pkey PRIMARY KEY (id),
	CONSTRAINT unique_template_role UNIQUE (template_id, role_id),
	CONSTRAINT efiling_template_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.efiling_roles(id) ON DELETE CASCADE,
	CONSTRAINT efiling_template_roles_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.efiling_templates(id) ON DELETE CASCADE
);
CREATE INDEX idx_template_roles_role ON public.efiling_template_roles USING btree (role_id);
CREATE INDEX idx_template_roles_template ON public.efiling_template_roles USING btree (template_id);


-- public.final_videos definition

-- Drop table

-- DROP TABLE public.final_videos;

CREATE TABLE public.final_videos (
	id serial4 NOT NULL,
	link text NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	work_request_id int4 NULL,
	description text NULL,
	geo_tag public.geometry NULL,
	creator_id int4 NULL,
	creator_type text NULL,
	creator_name text NULL,
	file_name text NULL,
	file_size int8 NULL,
	file_type text NULL,
	division_id int4 NULL,
	zone_id int4 NULL,
	CONSTRAINT final_videos_pkey PRIMARY KEY (id),
	CONSTRAINT final_videos_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT final_videos_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE,
	CONSTRAINT final_videos_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id)
);
CREATE INDEX idx_final_videos_creator ON public.final_videos USING btree (creator_id, creator_type);
CREATE INDEX idx_final_videos_division_zone ON public.final_videos USING btree (division_id, zone_id);
CREATE INDEX idx_final_videos_work_request_id ON public.final_videos USING btree (work_request_id);

-- Table Triggers

create trigger refresh_dashboard_on_final_videos_change after
insert
    or
delete
    or
update
    on
    public.final_videos for each statement execute function trigger_refresh_dashboard_view();


-- public.images definition

-- Drop table

-- DROP TABLE public.images;

CREATE TABLE public.images (
	id serial4 NOT NULL,
	link text NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	work_request_id int4 NULL,
	description text NULL,
	geo_tag public.geometry NULL,
	creator_id int4 NULL,
	creator_type varchar(20) NULL,
	file_name text NULL,
	file_size int8 NULL,
	file_type text NULL,
	creator_name text NULL,
	division_id int4 NULL,
	zone_id int4 NULL,
	CONSTRAINT images_pkey PRIMARY KEY (id),
	CONSTRAINT images_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT images_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE,
	CONSTRAINT images_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id)
);
CREATE INDEX idx_images_division_zone ON public.images USING btree (division_id, zone_id);
CREATE INDEX idx_images_work_request_id ON public.images USING btree (work_request_id);

-- Table Triggers

create trigger refresh_dashboard_on_images_change after
insert
    or
delete
    or
update
    on
    public.images for each statement execute function trigger_refresh_dashboard_view();


-- public.request_assign_agent definition

-- Drop table

-- DROP TABLE public.request_assign_agent;

CREATE TABLE public.request_assign_agent (
	id serial4 NOT NULL,
	work_requests_id int4 NOT NULL,
	agent_id int4 NOT NULL,
	status int4 DEFAULT 1 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT request_assign_agent_pkey PRIMARY KEY (id),
	CONSTRAINT fk_request_agent_agent FOREIGN KEY (agent_id) REFERENCES public.agents(id) ON DELETE CASCADE,
	CONSTRAINT fk_request_agent_work_request FOREIGN KEY (work_requests_id) REFERENCES public.work_requests(id) ON DELETE CASCADE
);
CREATE INDEX idx_request_assign_agent_agent_id ON public.request_assign_agent USING btree (agent_id);
CREATE INDEX idx_request_assign_agent_work_requests_id ON public.request_assign_agent USING btree (work_requests_id);


-- public.request_assign_smagent definition

-- Drop table

-- DROP TABLE public.request_assign_smagent;

CREATE TABLE public.request_assign_smagent (
	id serial4 NOT NULL,
	work_requests_id int4 NOT NULL,
	socialmedia_agent_id int4 NOT NULL,
	status int4 DEFAULT 1 NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT request_assign_smagent_pkey PRIMARY KEY (id),
	CONSTRAINT fk_request_smagent_socialmedia FOREIGN KEY (socialmedia_agent_id) REFERENCES public.socialmediaperson(id) ON DELETE CASCADE,
	CONSTRAINT fk_request_smagent_work_request FOREIGN KEY (work_requests_id) REFERENCES public.work_requests(id) ON DELETE CASCADE
);
CREATE INDEX idx_request_assign_smagent_smagent_id ON public.request_assign_smagent USING btree (socialmedia_agent_id);
CREATE INDEX idx_request_assign_smagent_work_requests_id ON public.request_assign_smagent USING btree (work_requests_id);

-- Table Triggers

create trigger refresh_dashboard_on_request_assign_smagent_change after
insert
    or
delete
    or
update
    on
    public.request_assign_smagent for each statement execute function trigger_refresh_dashboard_view();


-- public.videos definition

-- Drop table

-- DROP TABLE public.videos;

CREATE TABLE public.videos (
	id serial4 NOT NULL,
	link text NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	work_request_id int4 NULL,
	description text NULL,
	geo_tag public.geometry NULL,
	creator_id int4 NULL,
	creator_type varchar(20) NULL,
	file_name text NULL,
	file_size int8 NULL,
	file_type text NULL,
	creator_name text NULL,
	division_id int4 NULL,
	zone_id int4 NULL,
	CONSTRAINT videos_pkey PRIMARY KEY (id),
	CONSTRAINT videos_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id),
	CONSTRAINT videos_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE,
	CONSTRAINT videos_zone_id_fkey FOREIGN KEY (zone_id) REFERENCES public.efiling_zones(id)
);
CREATE INDEX idx_videos_division_zone ON public.videos USING btree (division_id, zone_id);
CREATE INDEX idx_videos_work_request_id ON public.videos USING btree (work_request_id);

-- Table Triggers

create trigger refresh_dashboard_on_videos_change after
insert
    or
delete
    or
update
    on
    public.videos for each statement execute function trigger_refresh_dashboard_view();


-- public.work definition

-- Drop table

-- DROP TABLE public.work;

CREATE TABLE public.work (
	id serial4 NOT NULL,
	subject varchar(255) NOT NULL,
	district_id int4 NULL,
	town_id int4 NULL,
	site_location text NULL,
	size_of_pipe varchar(50) NULL,
	length_of_pipe float8 NULL,
	allied_items text NULL,
	associated_work text NULL,
	survey_date date NULL,
	completion_date date NULL,
	geo_tag public.geometry NULL,
	before_image text NULL,
	after_image text NULL,
	assistant_id int4 NULL,
	shoot_date date NULL,
	link int4 NULL,
	expenditure_charge numeric NULL,
	complaint_type_id int4 NULL,
	complaint_subtype_id int4 NULL,
	status int4 NULL,
	CONSTRAINT work_pkey PRIMARY KEY (id),
	CONSTRAINT work_assistant_id_fkey FOREIGN KEY (assistant_id) REFERENCES public.users(id),
	CONSTRAINT work_complaint_subtype_id_fkey FOREIGN KEY (complaint_subtype_id) REFERENCES public.complaint_subtypes(id),
	CONSTRAINT work_complaint_type_id_fkey FOREIGN KEY (complaint_type_id) REFERENCES public.complaint_types(id),
	CONSTRAINT work_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id),
	CONSTRAINT work_link_fkey FOREIGN KEY (link) REFERENCES public.videos(id),
	CONSTRAINT work_status_fkey FOREIGN KEY (status) REFERENCES public.status(id),
	CONSTRAINT work_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id)
);


-- public.work_request_approvals definition

-- Drop table

-- DROP TABLE public.work_request_approvals;

CREATE TABLE public.work_request_approvals (
	id serial4 NOT NULL,
	work_request_id int4 NOT NULL,
	ceo_id int4 NOT NULL,
	approval_status varchar(20) DEFAULT 'pending'::character varying NOT NULL,
	approval_date timestamp NULL,
	rejection_reason text NULL,
	ceo_comments text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT chk_approval_status CHECK (((approval_status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying])::text[]))),
	CONSTRAINT work_request_approvals_pkey PRIMARY KEY (id),
	CONSTRAINT work_request_approvals_ceo_id_fkey FOREIGN KEY (ceo_id) REFERENCES public.users(id) ON DELETE CASCADE,
	CONSTRAINT work_request_approvals_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE
);
CREATE INDEX idx_work_request_approvals_ceo_id ON public.work_request_approvals USING btree (ceo_id);
CREATE INDEX idx_work_request_approvals_date ON public.work_request_approvals USING btree (approval_date);
CREATE INDEX idx_work_request_approvals_status ON public.work_request_approvals USING btree (approval_status);
CREATE INDEX idx_work_request_approvals_work_request_id ON public.work_request_approvals USING btree (work_request_id);

-- Table Triggers

create trigger refresh_dashboard_on_work_request_approvals_change after
insert
    or
delete
    or
update
    on
    public.work_request_approvals for each statement execute function trigger_refresh_dashboard_view();
create trigger update_work_request_status_trigger after
insert
    or
update
    on
    public.work_request_approvals for each row execute function update_work_request_status_on_approval();


-- public.work_request_locations definition

-- Drop table

-- DROP TABLE public.work_request_locations;

CREATE TABLE public.work_request_locations (
	id serial4 NOT NULL,
	work_request_id int4 NOT NULL,
	latitude numeric(10, 8) NOT NULL,
	longitude numeric(11, 8) NOT NULL,
	description text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT work_request_locations_pkey PRIMARY KEY (id),
	CONSTRAINT work_request_locations_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE
);
CREATE INDEX idx_work_request_locations_coordinates ON public.work_request_locations USING btree (latitude, longitude);
CREATE INDEX idx_work_request_locations_work_request_id ON public.work_request_locations USING btree (work_request_id);

-- Table Triggers

create trigger refresh_dashboard_on_work_request_locations_change after
insert
    or
delete
    or
update
    on
    public.work_request_locations for each statement execute function trigger_refresh_dashboard_view();


-- public.work_request_soft_approvals definition

-- Drop table

-- DROP TABLE public.work_request_soft_approvals;

CREATE TABLE public.work_request_soft_approvals (
	id serial4 NOT NULL,
	work_request_id int4 NOT NULL,
	approver_id int4 NOT NULL,
	approver_type varchar(20) NOT NULL,
	approval_status varchar(20) DEFAULT 'pending'::character varying NOT NULL,
	"comments" text NULL,
	approved_at timestamp NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT chk_approver_type CHECK (((approver_type)::text = ANY ((ARRAY['ceo'::character varying, 'coo'::character varying, 'ce'::character varying])::text[]))),
	CONSTRAINT chk_soft_approval_status CHECK (((approval_status)::text = ANY (ARRAY[('pending'::character varying)::text, ('approved'::character varying)::text, ('not_approved'::character varying)::text]))),
	CONSTRAINT work_request_soft_approvals_pkey PRIMARY KEY (id),
	CONSTRAINT work_request_soft_approvals_unique UNIQUE (work_request_id, approver_type),
	CONSTRAINT work_request_soft_approvals_approver_id_fkey FOREIGN KEY (approver_id) REFERENCES public.users(id) ON DELETE CASCADE,
	CONSTRAINT work_request_soft_approvals_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE
);
CREATE INDEX idx_work_request_soft_approvals_approver ON public.work_request_soft_approvals USING btree (approver_id, approver_type);
CREATE INDEX idx_work_request_soft_approvals_approver_type ON public.work_request_soft_approvals USING btree (approver_type);
CREATE INDEX idx_work_request_soft_approvals_status ON public.work_request_soft_approvals USING btree (approval_status);
CREATE INDEX idx_work_request_soft_approvals_work_request_id ON public.work_request_soft_approvals USING btree (work_request_id);

-- Table Triggers

create trigger update_work_request_soft_approvals_updated_at before
update
    on
    public.work_request_soft_approvals for each row execute function update_updated_at_column();


-- public.work_request_subtowns definition

-- Drop table

-- DROP TABLE public.work_request_subtowns;

CREATE TABLE public.work_request_subtowns (
	id serial4 NOT NULL,
	work_request_id int4 NOT NULL,
	subtown_id int4 NOT NULL,
	CONSTRAINT work_request_subtowns_pkey PRIMARY KEY (id),
	CONSTRAINT work_request_subtowns_work_request_id_subtown_id_key UNIQUE (work_request_id, subtown_id),
	CONSTRAINT work_request_subtowns_subtown_id_fkey FOREIGN KEY (subtown_id) REFERENCES public.subtown(id) ON DELETE CASCADE,
	CONSTRAINT work_request_subtowns_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id) ON DELETE CASCADE
);


-- public.main definition

-- Drop table

-- DROP TABLE public.main;

CREATE TABLE public.main (
	id serial4 NOT NULL,
	agent_id int4 NULL,
	social_media_person_id int4 NULL,
	work_id int4 NULL,
	CONSTRAINT main_pkey PRIMARY KEY (id),
	CONSTRAINT main_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id),
	CONSTRAINT main_social_media_person_id_fkey FOREIGN KEY (social_media_person_id) REFERENCES public.socialmediaperson(id),
	CONSTRAINT main_work_id_fkey FOREIGN KEY (work_id) REFERENCES public.work(id)
);


-- public.efiling_comments definition

-- Drop table

-- DROP TABLE public.efiling_comments;

CREATE TABLE public.efiling_comments (
	id serial4 NOT NULL,
	file_id int4 NULL,
	user_id int4 NULL,
	"comment" text NOT NULL,
	is_internal bool DEFAULT false NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_comments_pkey PRIMARY KEY (id)
);


-- public.efiling_document_comments definition

-- Drop table

-- DROP TABLE public.efiling_document_comments;

CREATE TABLE public.efiling_document_comments (
	id serial4 NOT NULL,
	file_id int4 NOT NULL,
	user_id int4 NOT NULL,
	user_name varchar(255) NOT NULL,
	user_role varchar(100) NOT NULL,
	"text" text NOT NULL,
	"timestamp" timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	edited bool DEFAULT false NULL,
	edited_at timestamp NULL,
	is_active bool DEFAULT true NULL,
	CONSTRAINT efiling_document_comments_pkey PRIMARY KEY (id)
);


-- public.efiling_document_pages definition

-- Drop table

-- DROP TABLE public.efiling_document_pages;

CREATE TABLE public.efiling_document_pages (
	id serial4 NOT NULL,
	file_id int4 NOT NULL,
	page_number int4 NOT NULL,
	page_title varchar(255) NULL,
	page_content text NULL,
	page_type varchar(50) DEFAULT 'MAIN'::character varying NULL,
	is_active bool DEFAULT true NULL,
	created_by int4 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_document_pages_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_efiling_document_pages_file ON public.efiling_document_pages USING btree (file_id);
CREATE INDEX idx_efiling_document_pages_number ON public.efiling_document_pages USING btree (file_id, page_number);


-- public.efiling_document_signatures definition

-- Drop table

-- DROP TABLE public.efiling_document_signatures;

CREATE TABLE public.efiling_document_signatures (
	id serial4 NOT NULL,
	file_id int4 NOT NULL,
	user_id int4 NOT NULL,
	user_name varchar(255) NOT NULL,
	user_role varchar(100) NOT NULL,
	"type" varchar(50) NOT NULL,
	"content" text NOT NULL,
	"position" jsonb NOT NULL,
	font varchar(100) NULL,
	"timestamp" timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	is_active bool DEFAULT true NULL,
	color varchar(20) DEFAULT 'black'::character varying NULL,
	user_designation varchar(255) NULL,
	user_town_id int4 NULL,
	user_division_id int4 NULL,
	CONSTRAINT efiling_document_signatures_pkey PRIMARY KEY (id)
);


-- public.efiling_documents definition

-- Drop table

-- DROP TABLE public.efiling_documents;

CREATE TABLE public.efiling_documents (
	id serial4 NOT NULL,
	file_id int4 NULL,
	document_type varchar(100) NOT NULL,
	title varchar(255) NOT NULL,
	description text NULL,
	file_path varchar(500) NULL,
	file_size int4 NULL,
	mime_type varchar(100) NULL,
	uploaded_by int4 NULL,
	uploaded_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	is_active bool DEFAULT true NULL,
	CONSTRAINT efiling_documents_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_efiling_documents_file ON public.efiling_documents USING btree (file_id);


-- public.efiling_file_movements definition

-- Drop table

-- DROP TABLE public.efiling_file_movements;

CREATE TABLE public.efiling_file_movements (
	id serial4 NOT NULL,
	file_id int4 NULL,
	from_user_id int4 NULL,
	to_user_id int4 NULL,
	from_department_id int4 NULL,
	to_department_id int4 NULL,
	action_type varchar(50) NOT NULL,
	remarks text NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	is_team_internal bool DEFAULT false NULL,
	is_return_to_creator bool DEFAULT false NULL,
	tat_started bool DEFAULT false NULL,
	from_user_name varchar(255) NULL,
	from_user_designation varchar(255) NULL,
	from_user_town_id int4 NULL,
	from_user_division_id int4 NULL,
	to_user_name varchar(255) NULL,
	to_user_designation varchar(255) NULL,
	to_user_town_id int4 NULL,
	to_user_division_id int4 NULL,
	CONSTRAINT efiling_file_movements_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_efiling_file_movements_file ON public.efiling_file_movements USING btree (file_id);
CREATE INDEX idx_movements_created_at ON public.efiling_file_movements USING btree (created_at);
CREATE INDEX idx_movements_file ON public.efiling_file_movements USING btree (file_id);
CREATE INDEX idx_movements_from_user ON public.efiling_file_movements USING btree (from_user_id);
CREATE INDEX idx_movements_return_to_creator ON public.efiling_file_movements USING btree (is_return_to_creator) WHERE (is_return_to_creator = true);
CREATE INDEX idx_movements_tat_started ON public.efiling_file_movements USING btree (tat_started) WHERE (tat_started = true);
CREATE INDEX idx_movements_team_internal ON public.efiling_file_movements USING btree (is_team_internal) WHERE (is_team_internal = true);
CREATE INDEX idx_movements_to_user ON public.efiling_file_movements USING btree (to_user_id);

-- Table Triggers

create trigger trigger_update_workflow_state after
insert
    on
    public.efiling_file_movements for each row execute function update_workflow_state_on_movement();


-- public.efiling_file_page_additions definition

-- Drop table

-- DROP TABLE public.efiling_file_page_additions;

CREATE TABLE public.efiling_file_page_additions (
	id serial4 NOT NULL,
	file_id int4 NOT NULL,
	page_id int4 NOT NULL,
	added_by int4 NOT NULL,
	added_by_role_code varchar(50) NULL,
	addition_type varchar(50) DEFAULT 'CE_PAGE'::character varying NULL,
	added_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	notes text NULL,
	CONSTRAINT efiling_file_page_additions_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_page_additions_file ON public.efiling_file_page_additions USING btree (file_id);
CREATE INDEX idx_page_additions_type ON public.efiling_file_page_additions USING btree (addition_type);
CREATE INDEX idx_page_additions_user ON public.efiling_file_page_additions USING btree (added_by);


-- public.efiling_file_workflow_states definition

-- Drop table

-- DROP TABLE public.efiling_file_workflow_states;

CREATE TABLE public.efiling_file_workflow_states (
	id serial4 NOT NULL,
	file_id int4 NOT NULL,
	current_state varchar(50) DEFAULT 'TEAM_INTERNAL'::character varying NOT NULL,
	current_assigned_to int4 NULL,
	creator_id int4 NOT NULL,
	is_within_team bool DEFAULT true NULL,
	tat_started bool DEFAULT false NULL,
	tat_started_at timestamp NULL,
	last_external_mark_at timestamp NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT check_state_values CHECK (((current_state)::text = ANY ((ARRAY['TEAM_INTERNAL'::character varying, 'EXTERNAL'::character varying, 'RETURNED_TO_CREATOR'::character varying])::text[]))),
	CONSTRAINT efiling_file_workflow_states_pkey PRIMARY KEY (id),
	CONSTRAINT unique_file_state UNIQUE (file_id)
);
CREATE INDEX idx_workflow_state_assigned ON public.efiling_file_workflow_states USING btree (current_assigned_to);
CREATE INDEX idx_workflow_state_creator ON public.efiling_file_workflow_states USING btree (creator_id);
CREATE INDEX idx_workflow_state_file ON public.efiling_file_workflow_states USING btree (file_id);
CREATE INDEX idx_workflow_state_team ON public.efiling_file_workflow_states USING btree (is_within_team) WHERE (is_within_team = true);
CREATE INDEX idx_workflow_state_type ON public.efiling_file_workflow_states USING btree (current_state);

-- Table Triggers

create trigger trigger_update_workflow_state_updated_at before
update
    on
    public.efiling_file_workflow_states for each row execute function update_team_updated_at();


-- public.efiling_files definition

-- Drop table

-- DROP TABLE public.efiling_files;

CREATE TABLE public.efiling_files (
	id serial4 NOT NULL,
	file_number varchar(100) NOT NULL,
	subject varchar(500) NOT NULL,
	category_id int4 NULL,
	department_id int4 NULL,
	status_id int4 NULL,
	priority varchar(20) DEFAULT 'normal'::character varying NULL,
	confidentiality_level varchar(20) DEFAULT 'normal'::character varying NULL,
	work_request_id int4 NULL,
	created_by int4 NULL,
	assigned_to int4 NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	closed_at timestamp NULL,
	remarks text NULL,
	file_type_id int4 NULL,
	sla_deadline timestamp NULL,
	sla_breached bool DEFAULT false NULL,
	document_content jsonb DEFAULT '{}'::jsonb NULL,
	page_count int4 DEFAULT 1 NULL,
	district_id int4 NULL,
	town_id int4 NULL,
	division_id int4 NULL,
	workflow_state_id int4 NULL,
	sla_paused bool DEFAULT false NULL,
	sla_paused_at timestamp NULL,
	sla_accumulated_hours numeric(10, 2) DEFAULT 0 NULL,
	sla_pause_count int4 DEFAULT 0 NULL,
	CONSTRAINT efiling_files_file_number_key UNIQUE (file_number),
	CONSTRAINT efiling_files_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_efiling_files_assigned_to ON public.efiling_files USING btree (assigned_to);
CREATE INDEX idx_efiling_files_created_by ON public.efiling_files USING btree (created_by);
CREATE INDEX idx_efiling_files_department ON public.efiling_files USING btree (department_id);
CREATE INDEX idx_efiling_files_district ON public.efiling_files USING btree (district_id);
CREATE INDEX idx_efiling_files_division ON public.efiling_files USING btree (division_id);
CREATE INDEX idx_efiling_files_file_type ON public.efiling_files USING btree (file_type_id);
CREATE INDEX idx_efiling_files_location ON public.efiling_files USING btree (district_id, town_id, division_id);
CREATE INDEX idx_efiling_files_sla_deadline ON public.efiling_files USING btree (sla_deadline);
CREATE INDEX idx_efiling_files_status ON public.efiling_files USING btree (status_id);
CREATE INDEX idx_efiling_files_town ON public.efiling_files USING btree (town_id);
CREATE INDEX idx_efiling_files_work_request ON public.efiling_files USING btree (work_request_id);
CREATE INDEX idx_efiling_files_workflow_state ON public.efiling_files USING btree (workflow_state_id);


-- public.efiling_notifications definition

-- Drop table

-- DROP TABLE public.efiling_notifications;

CREATE TABLE public.efiling_notifications (
	id serial4 NOT NULL,
	user_id int4 NOT NULL,
	"type" varchar(100) NOT NULL,
	file_id int4 NULL,
	message text NOT NULL,
	priority varchar(20) DEFAULT 'normal'::character varying NULL,
	action_required bool DEFAULT false NULL,
	expires_at timestamp NULL,
	metadata jsonb DEFAULT '{}'::jsonb NULL,
	is_read bool DEFAULT false NULL,
	read_at timestamp NULL,
	is_dismissed bool DEFAULT false NULL,
	dismissed_at timestamp NULL,
	is_deleted bool DEFAULT false NULL,
	deleted_at timestamp NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_notifications_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_efiling_notifications_created ON public.efiling_notifications USING btree (created_at);
CREATE INDEX idx_efiling_notifications_expires ON public.efiling_notifications USING btree (expires_at) WHERE (expires_at IS NOT NULL);
CREATE INDEX idx_efiling_notifications_file ON public.efiling_notifications USING btree (file_id);
CREATE INDEX idx_efiling_notifications_priority ON public.efiling_notifications USING btree (priority);
CREATE INDEX idx_efiling_notifications_type ON public.efiling_notifications USING btree (type);
CREATE INDEX idx_efiling_notifications_unread ON public.efiling_notifications USING btree (user_id, is_read) WHERE (is_read = false);
CREATE INDEX idx_efiling_notifications_user ON public.efiling_notifications USING btree (user_id);

-- Table Triggers

create trigger update_efiling_notifications_updated_at before
update
    on
    public.efiling_notifications for each row execute function update_efiling_notifications_updated_at();


-- public.efiling_signatures definition

-- Drop table

-- DROP TABLE public.efiling_signatures;

CREATE TABLE public.efiling_signatures (
	id serial4 NOT NULL,
	file_id int4 NOT NULL,
	user_id int4 NULL,
	signature_text text NOT NULL,
	signature_method varchar(50) NOT NULL,
	signed_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	status varchar(50) DEFAULT 'SIGNED'::character varying NULL,
	ip_address inet NULL,
	user_agent text NULL,
	CONSTRAINT efiling_signatures_pkey PRIMARY KEY (id)
);


-- public.efiling_sla_pause_history definition

-- Drop table

-- DROP TABLE public.efiling_sla_pause_history;

CREATE TABLE public.efiling_sla_pause_history (
	id serial4 NOT NULL,
	file_id int4 NOT NULL,
	paused_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
	resumed_at timestamp NULL,
	pause_reason varchar(100) DEFAULT 'CEO_REVIEW'::character varying NULL,
	paused_by_user_id int4 NULL,
	paused_by_role_id int4 NULL,
	duration_hours numeric(10, 2) NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT efiling_sla_pause_history_pkey PRIMARY KEY (id)
);
CREATE INDEX idx_sla_pause_history_file ON public.efiling_sla_pause_history USING btree (file_id);

-- Table Triggers

create trigger trigger_update_sla_pause_history_updated_at before
update
    on
    public.efiling_sla_pause_history for each row execute function update_sla_pause_history_updated_at();


-- public.efiling_comments foreign keys

ALTER TABLE public.efiling_comments ADD CONSTRAINT efiling_comments_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;
ALTER TABLE public.efiling_comments ADD CONSTRAINT efiling_comments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.efiling_users(id);


-- public.efiling_document_comments foreign keys

ALTER TABLE public.efiling_document_comments ADD CONSTRAINT efiling_document_comments_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id);
ALTER TABLE public.efiling_document_comments ADD CONSTRAINT efiling_document_comments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


-- public.efiling_document_pages foreign keys

ALTER TABLE public.efiling_document_pages ADD CONSTRAINT efiling_document_pages_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_document_pages ADD CONSTRAINT efiling_document_pages_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;


-- public.efiling_document_signatures foreign keys

ALTER TABLE public.efiling_document_signatures ADD CONSTRAINT efiling_document_signatures_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id);
ALTER TABLE public.efiling_document_signatures ADD CONSTRAINT efiling_document_signatures_user_division_id_fkey FOREIGN KEY (user_division_id) REFERENCES public.divisions(id);
ALTER TABLE public.efiling_document_signatures ADD CONSTRAINT efiling_document_signatures_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);
ALTER TABLE public.efiling_document_signatures ADD CONSTRAINT efiling_document_signatures_user_town_id_fkey FOREIGN KEY (user_town_id) REFERENCES public.town(id);


-- public.efiling_documents foreign keys

ALTER TABLE public.efiling_documents ADD CONSTRAINT efiling_documents_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;
ALTER TABLE public.efiling_documents ADD CONSTRAINT efiling_documents_uploaded_by_fkey FOREIGN KEY (uploaded_by) REFERENCES public.efiling_users(id);


-- public.efiling_file_movements foreign keys

ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_from_department_id_fkey FOREIGN KEY (from_department_id) REFERENCES public.efiling_departments(id);
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_from_user_division_id_fkey FOREIGN KEY (from_user_division_id) REFERENCES public.divisions(id);
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_from_user_id_fkey FOREIGN KEY (from_user_id) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_from_user_town_id_fkey FOREIGN KEY (from_user_town_id) REFERENCES public.town(id);
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_to_department_id_fkey FOREIGN KEY (to_department_id) REFERENCES public.efiling_departments(id);
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_to_user_division_id_fkey FOREIGN KEY (to_user_division_id) REFERENCES public.divisions(id);
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_to_user_id_fkey FOREIGN KEY (to_user_id) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_file_movements ADD CONSTRAINT efiling_file_movements_to_user_town_id_fkey FOREIGN KEY (to_user_town_id) REFERENCES public.town(id);


-- public.efiling_file_page_additions foreign keys

ALTER TABLE public.efiling_file_page_additions ADD CONSTRAINT efiling_file_page_additions_added_by_fkey FOREIGN KEY (added_by) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_file_page_additions ADD CONSTRAINT efiling_file_page_additions_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;
ALTER TABLE public.efiling_file_page_additions ADD CONSTRAINT efiling_file_page_additions_page_id_fkey FOREIGN KEY (page_id) REFERENCES public.efiling_document_pages(id) ON DELETE CASCADE;


-- public.efiling_file_workflow_states foreign keys

ALTER TABLE public.efiling_file_workflow_states ADD CONSTRAINT efiling_file_workflow_states_creator_id_fkey FOREIGN KEY (creator_id) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_file_workflow_states ADD CONSTRAINT efiling_file_workflow_states_current_assigned_to_fkey FOREIGN KEY (current_assigned_to) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_file_workflow_states ADD CONSTRAINT efiling_file_workflow_states_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;


-- public.efiling_files foreign keys

ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.efiling_file_categories(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.efiling_users(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.efiling_departments(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_district_id_fkey FOREIGN KEY (district_id) REFERENCES public.district(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_division_id_fkey FOREIGN KEY (division_id) REFERENCES public.divisions(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_file_type_id_fkey FOREIGN KEY (file_type_id) REFERENCES public.efiling_file_types(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_status_id_fkey FOREIGN KEY (status_id) REFERENCES public.efiling_file_status(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_town_id_fkey FOREIGN KEY (town_id) REFERENCES public.town(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_work_request_id_fkey FOREIGN KEY (work_request_id) REFERENCES public.work_requests(id);
ALTER TABLE public.efiling_files ADD CONSTRAINT efiling_files_workflow_state_id_fkey FOREIGN KEY (workflow_state_id) REFERENCES public.efiling_file_workflow_states(id);


-- public.efiling_notifications foreign keys

ALTER TABLE public.efiling_notifications ADD CONSTRAINT efiling_notifications_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;
ALTER TABLE public.efiling_notifications ADD CONSTRAINT efiling_notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.efiling_users(id) ON DELETE CASCADE;


-- public.efiling_signatures foreign keys

ALTER TABLE public.efiling_signatures ADD CONSTRAINT efiling_signatures_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;


-- public.efiling_sla_pause_history foreign keys

ALTER TABLE public.efiling_sla_pause_history ADD CONSTRAINT efiling_sla_pause_history_file_id_fkey FOREIGN KEY (file_id) REFERENCES public.efiling_files(id) ON DELETE CASCADE;
ALTER TABLE public.efiling_sla_pause_history ADD CONSTRAINT efiling_sla_pause_history_paused_by_role_id_fkey FOREIGN KEY (paused_by_role_id) REFERENCES public.efiling_roles(id);
ALTER TABLE public.efiling_sla_pause_history ADD CONSTRAINT efiling_sla_pause_history_paused_by_user_id_fkey FOREIGN KEY (paused_by_user_id) REFERENCES public.efiling_users(id);